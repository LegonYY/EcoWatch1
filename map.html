<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EcoWatch - –ö–∞—Ä—Ç–∞ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–æ–≤ –µ–ª–∏</title>

    <!-- Meta Tags -->
    <meta name="description"
        content="–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –∫–∞—Ä—Ç–∞ –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –∏ –∏–∑—É—á–µ–Ω–∏—è —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–æ–≤ –æ—Ç –µ–ª–µ–π. –®–∫–æ–ª—å–Ω—ã–π –Ω–∞—É—á–Ω—ã–π –ø—Ä–æ–µ–∫—Ç." />
    <meta name="author" content="–ü–∞—à–∫–∏–Ω–∞ –ï–∫–∞—Ç–µ—Ä–∏–Ω–∞, –ö–ì–£ –°—Ä–µ–¥–Ω—è—è —à–∫–æ–ª–∞ ‚Ññ 7 –≥–æ—Ä–æ–¥–∞ –ê–ª—Ç–∞–π" />

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Leaflet CSS &amp; JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <!-- HTML2Canvas for pixel analysis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        #map {
            height: 100vh;
            height: 100dvh;
            /* Mobile browser support */
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        .leaflet-draw-toolbar a {
            background-color: white !important;
        }

        /* Hide Leaflet attribution */
        .leaflet-control-attribution {
            display: none !important;
        }

        /* Move Leaflet controls lower to avoid overlap with sticky header */
        .leaflet-top {
            top: 85px !important;
        }

        /* Custom gradient for heatmap legend */
        .gradient-bar {
            background: linear-gradient(to right,
                    rgba(34, 139, 34, 0.1),
                    rgba(34, 139, 34, 0.3),
                    rgba(34, 139, 34, 0.5),
                    rgba(34, 139, 34, 0.7),
                    rgba(34, 139, 34, 0.9));
        }

        /* Canvas for particles */
        #particleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 400;
        }

        /* Canvas for wind visualization */
        #windCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 350;
        }

        /* Tree marker shadow effect */
        .tree-marker {
            filter: drop-shadow(0 0 4px rgba(0, 0, 0, 0.8));
        }

        /* Smooth transitions for dark mode */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        /* Language dropdown */
        .lang-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            min-width: 150px;
            z-index: 50;
        }

        .dark .lang-dropdown {
            background: #1e293b;
        }

        .lang-dropdown.active {
            display: block;
        }

        .lang-option {
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .lang-option:hover {
            background: #f3f4f6;
        }

        .dark .lang-option:hover {
            background: #334155;
        }

        /* Performance optimizations - prevent jitter on map movement */
        .fixed {
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        /* Smooth rendering for control panel */
        #controlPanel {
            will-change: transform;
            transform: translateZ(0);
        }

        /* Smooth rendering for buttons and UI elements */
        button,
        .pointer-events-auto {
            will-change: transform;
            transform: translateZ(0);
        }
    </style>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        forest: {
                            50: '#f0fdf4',
                            100: '#dcfce7',
                            200: '#bbf7d0',
                            300: '#86efac',
                            400: '#4ade80',
                            500: '#22c55e',
                            600: '#16a34a',
                            700: '#15803d',
                            800: '#166534',
                            900: '#14532d',
                        }
                    }
                }
            }
        }
    </script>
</head>

<body class="bg-gray-50 dark:bg-gray-900">

    <!-- Top Header Bar -->
    <div class="absolute top-4 left-4 right-4 z-[999] flex items-center justify-between pointer-events-none">
        <!-- Back Button & Controls Container -->
        <!-- Unified Controls Container -->
        <div class="flex items-center bg-white dark:bg-gray-800 rounded-lg shadow-lg pointer-events-auto p-1">
            <!-- Back Button -->
            <a href="index.html"
                class="hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-800 dark:text-gray-100 px-3 py-2 rounded-md transition-colors flex items-center gap-2 font-semibold focus:outline-none focus:ring-2 focus:ring-forest-500">
                <i class="fas fa-arrow-left"></i>
                <span data-i18n="backButton" class="hidden md:inline">–ù–∞ –≥–ª–∞–≤–Ω—É—é</span>
            </a>

            <!-- Divider -->
            <div class="w-px h-6 bg-gray-200 dark:bg-gray-700 mx-1"></div>

            <!-- Language and Theme Controls -->
            <div class="flex items-center gap-1">
                <!-- Language Selector -->
                <div class="relative">
                    <button id="langBtn"
                        class="flex items-center gap-2 px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-forest-500">
                        <i class="fas fa-globe"></i>
                        <span id="currentLang">RU</span>
                        <i class="fas fa-chevron-down text-xs"></i>
                    </button>
                    <!-- Dropdown positioned relative to button -->
                    <div id="langDropdown" class="lang-dropdown mt-2">
                        <div class="lang-option" data-lang="ru"><span>üá∑üá∫</span><span
                                class="text-gray-700 dark:text-gray-200">–†—É—Å—Å–∫–∏–π</span></div>
                        <div class="lang-option" data-lang="kz"><span>üá∞üáø</span><span
                                class="text-gray-700 dark:text-gray-200">“ö–∞–∑–∞“õ—à–∞</span></div>
                        <div class="lang-option" data-lang="en"><span>üá¨üáß</span><span
                                class="text-gray-700 dark:text-gray-200">English</span></div>
                        <div class="lang-option" data-lang="es"><span>üá™üá∏</span><span
                                class="text-gray-700 dark:text-gray-200">Espa√±ol</span></div>
                        <div class="lang-option" data-lang="zh"><span>üá®üá≥</span><span
                                class="text-gray-700 dark:text-gray-200">‰∏≠Êñá</span></div>
                    </div>
                </div>

                <!-- Divider -->
                <div class="w-px h-6 bg-gray-200 dark:bg-gray-700 mx-1"></div>

                <!-- Theme Toggle -->
                <button id="themeToggle"
                    class="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-700 dark:text-gray-200 transition-colors focus:outline-none focus:ring-2 focus:ring-forest-500">
                    <i class="fas fa-moon dark:hidden"></i>
                    <i class="fas fa-sun hidden dark:inline"></i>
                </button>
            </div>
        </div>

        <!-- Mobile Settings Toggle -->
        <button id="mobileSettingsBtn"
            class="md:hidden pointer-events-auto bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-200 p-3 rounded-full shadow-lg focus:outline-none focus:ring-2 focus:ring-forest-500">
            <i class="fas fa-sliders-h"></i>
        </button>
    </div>


    <!-- Control Panel / Drawer -->
    <!-- Control Panel / Drawer -->
    <div id="controlPanel"
        class="fixed z-[2000] transition-transform duration-300 ease-in-out
               bottom-0 left-0 right-0 h-[85vh] translate-y-full bg-transparent shadow-none pointer-events-none
               md:top-4 md:right-4 md:bottom-auto md:left-auto md:w-96 md:h-auto md:max-h-[calc(100vh-2rem)] md:translate-y-0 md:bg-transparent md:pointer-events-auto">

        <!-- Inner Container -->
        <div
            class="flex flex-col h-full md:h-auto md:max-h-[calc(100vh-2rem)] pointer-events-auto shadow-2xl md:shadow-none">
            <!-- Mobile Handle / Header -->
            <div class="md:hidden flex justify-center pt-2 pb-1 bg-white dark:bg-gray-800 rounded-t-2xl border-b border-gray-100 dark:border-gray-700 cursor-pointer w-full"
                id="drawerHandle">
                <div class="w-12 h-1.5 bg-gray-300 dark:bg-gray-600 rounded-full"></div>
            </div>

            <div
                class="bg-white dark:bg-gray-800 md:rounded-lg shadow-xl md:shadow-2xl border-t md:border border-gray-200 dark:border-gray-700 flex flex-col h-full md:h-auto md:max-h-[calc(100vh-2rem)] md:min-h-0 w-full">

                <!-- Header -->
                <div
                    class="bg-gradient-to-r from-forest-600 to-forest-700 dark:from-forest-500 dark:to-forest-600 text-white p-4 md:rounded-t-lg flex justify-between items-center shrink-0">
                    <div>
                        <h1 class="text-xl font-bold flex items-center gap-2">
                            <i class="fas fa-tree"></i>
                            <span class="md:inline" data-i18n="panelTitle">–§–∏—Ç–æ–Ω—Ü–∏–¥—ã –µ–ª–∏</span>
                        </h1>
                        <p class="text-sm text-forest-100/90 mt-1 hidden md:block" data-i18n="panelSubtitle">
                            –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è
                            –∫–∞—Ä—Ç–∞ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è</p>
                    </div>
                    <!-- Close Button (Mobile) -->
                    <button id="closePanelBtn"
                        class="md:hidden p-2 text-white hover:bg-white/20 rounded-lg focus:outline-none focus:ring-2 focus:ring-white/50">
                        <i class="fas fa-times"></i>
                    </button>
                </div>

                <!-- Mobile Tabs (Optional for better UX on small screens, keeping simple for now) -->

                <!-- Controls Container (Scrollable) -->
                <div class="p-4 space-y-4 dark:bg-gray-800 overflow-y-auto flex-1 overscroll-contain md:max-h-[calc(100vh-12rem)]"
                    style="-webkit-overflow-scrolling: touch;">


                    <!-- Work Mode -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 dark:text-gray-200 mb-2">
                            <i class="fas fa-cog text-forest-600 dark:text-forest-400"></i> <span
                                data-i18n="workMode">–†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã</span>
                        </label>
                        <select id="workMode"
                            class="w-full bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 dark:text-gray-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-forest-500 focus:border-transparent">
                            <option value="polygon" data-i18n="workModePolygon">–†–∏—Å–æ–≤–∞–Ω–∏–µ –æ–±–ª–∞—Å—Ç–∏ (–∞–≤—Ç–æ-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è)
                            </option>
                            <option value="manual" data-i18n="workModeManual">–†—É—á–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –¥–µ—Ä–µ–≤—å–µ–≤</option>
                        </select>
                    </div>

                    <!-- Instructions -->
                    <div id="instructionBox"
                        class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800/50 rounded-lg p-3 text-sm">
                        <div class="flex items-start gap-2">
                            <i class="fas fa-info-circle text-blue-600 dark:text-blue-400 mt-0.5"></i>
                            <div class="text-blue-900 dark:text-blue-200">
                                <strong data-i18n="instructionBoxTitle">–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:</strong> <span id="instructionText"
                                    data-i18n="instructionBoxText">–ù–∞–∂–º–∏—Ç–µ <i class="fas fa-draw-polygon text-xs"></i>
                                    –Ω–∞ –∫–∞—Ä—Ç–µ, –∑–∞—Ç–µ–º –∫–ª–∏–∫–∞–π—Ç–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è
                                    –ø–æ–ª–∏–≥–æ–Ω–∞ –ª–µ—Å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –∑–∞–≤–µ—Ä—à–∞–µ—Ç —Ä–∏—Å–æ–≤–∞–Ω–∏–µ.</span>
                            </div>
                        </div>
                    </div>

                    <!-- Map Layer Selection -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <i class="fas fa-layer-group text-forest-600"></i> <span data-i18n="mapLayer">–°–ª–æ–π
                                –∫–∞—Ä—Ç—ã</span>
                        </label>
                        <select id="mapLayer"
                            class="w-full bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 dark:text-gray-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-forest-500 focus:border-transparent">
                            <option value="osm" data-i18n="mapLayerOsm">–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∫–∞—Ä—Ç–∞</option>
                            <option value="satellite" selected="" data-i18n="mapLayerSatellite">–°–ø—É—Ç–Ω–∏–∫–æ–≤–∞—è (–¥–ª—è
                                –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ª–µ—Å–æ–≤)</option>
                        </select>
                    </div>

                    <!-- Section Divider -->
                    <div class="border-t border-gray-300 my-2"></div>
                    <div class="text-xs font-bold text-gray-500 uppercase tracking-wide mb-2" data-i18n="treeSection">
                        –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–µ—Ä–µ–≤—å–µ–≤</div>

                    <!-- Tree Density -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <i class="fas fa-seedling text-forest-600"></i> <span data-i18n="treeDensity">–ü–ª–æ—Ç–Ω–æ—Å—Ç—å
                                –¥–µ—Ä–µ–≤—å–µ–≤</span>
                        </label>
                        <input type="range" id="treeDensity" min="5" max="50" value="20"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-forest-600" />
                        <div class="flex justify-between text-xs text-gray-600 mt-1">
                            <span data-i18n="densityRare">–†–µ–¥–∫–æ (5/–≥–∞)</span>
                            <span id="treeDensityValue"
                                class="font-semibold text-forest-700 dark:text-forest-400">20/–≥–∞</span>
                            <span data-i18n="densityDense">–ì—É—Å—Ç–æ (50/–≥–∞)</span>
                        </div>
                    </div>

                    <!-- Section Divider -->
                    <div class="border-t border-gray-300 my-2"></div>
                    <div class="text-xs font-bold text-gray-500 uppercase tracking-wide mb-2"
                        data-i18n="environmentSection">–û–∫—Ä—É–∂–∞—é—â–∞—è —Å—Ä–µ–¥–∞</div>

                    <!-- Season -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <i class="fas fa-calendar text-forest-600"></i> <span data-i18n="season">–°–µ–∑–æ–Ω</span>
                        </label>
                        <select id="season"
                            class="w-full bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 dark:text-gray-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-forest-500 focus:border-transparent">
                            <option value="spring" data-i18n="seasonSpring">–í–µ—Å–Ω–∞ (‚Üë –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å)</option>
                            <option value="summer" selected="" data-i18n="seasonSummer">–õ–µ—Ç–æ (–º–∞–∫—Å–∏–º—É–º)</option>
                            <option value="autumn" data-i18n="seasonAutumn">–û—Å–µ–Ω—å (‚Üì –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å)</option>
                            <option value="winter" data-i18n="seasonWinter">–ó–∏–º–∞ (–º–∏–Ω–∏–º—É–º)</option>
                        </select>
                    </div>

                    <!-- Time of Day -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <i class="fas fa-clock text-forest-600"></i> <span data-i18n="timeOfDay">–í—Ä–µ–º—è —Å—É—Ç–æ–∫</span>
                        </label>
                        <select id="timeOfDay"
                            class="w-full bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 dark:text-gray-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-forest-500 focus:border-transparent">
                            <option value="morning" data-i18n="timeMorning">–£—Ç—Ä–æ (6:00-12:00)</option>
                            <option value="day" selected="" data-i18n="timeDay">–î–µ–Ω—å (12:00-18:00)</option>
                            <option value="evening" data-i18n="timeEvening">–í–µ—á–µ—Ä (18:00-22:00)</option>
                            <option value="night" data-i18n="timeNight">–ù–æ—á—å (22:00-6:00)</option>
                        </select>
                    </div>

                    <!-- Weather -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <i class="fas fa-cloud-sun text-forest-600"></i> <span data-i18n="weather">–ü–æ–≥–æ–¥–∞</span>
                        </label>
                        <select id="weather"
                            class="w-full bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 dark:text-gray-200 rounded-lg px-3 py-2 text-sm focus:ring-2 focus:ring-forest-500 focus:border-transparent">
                            <option value="sunny" selected="" data-i18n="weatherSunny">–°–æ–ª–Ω–µ—á–Ω–æ (‚Üë –≤—ã–¥–µ–ª–µ–Ω–∏–µ)</option>
                            <option value="cloudy" data-i18n="weatherCloudy">–û–±–ª–∞—á–Ω–æ (–Ω–æ—Ä–º–∞)</option>
                            <option value="rainy" data-i18n="weatherRainy">–î–æ–∂–¥—å (‚Üì –≤—ã–¥–µ–ª–µ–Ω–∏–µ)</option>
                            <option value="foggy" data-i18n="weatherFoggy">–¢—É–º–∞–Ω (–ø–ª–æ—Ö–æ–µ —Ä–∞—Å—Å–µ–∏–≤–∞–Ω–∏–µ)</option>
                        </select>
                    </div>

                    <!-- Section Divider -->
                    <div class="border-t border-gray-300 my-2"></div>
                    <div class="text-xs font-bold text-gray-500 uppercase tracking-wide mb-2" data-i18n="windSection">
                        –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–µ—Ç—Ä–∞</div>

                    <!-- Wind Speed -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <i class="fas fa-wind text-forest-600"></i> <span data-i18n="windSpeed">–°–∫–æ—Ä–æ—Å—Ç—å
                                –≤–µ—Ç—Ä–∞</span>
                        </label>
                        <input type="range" id="windSpeed" min="0" max="10" value="3" step="0.5"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-forest-600" />
                        <div class="flex justify-between text-xs text-gray-600 mt-1">
                            <span data-i18n="windCalm">–®—Ç–∏–ª—å</span>
                            <span id="windSpeedValue" class="font-semibold text-forest-700 dark:text-forest-400">3
                                –º/—Å</span>
                            <span data-i18n="windStrong">–°–∏–ª—å–Ω—ã–π</span>
                        </div>
                    </div>

                    <!-- Wind Direction -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <i class="fas fa-compass text-forest-600"></i> <span data-i18n="windDirection">–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                                –≤–µ—Ç—Ä–∞</span>
                        </label>
                        <input type="range" id="windDirection" min="0" max="360" value="90" step="15"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-forest-600" />
                        <div class="flex justify-between text-xs text-gray-600 mt-1">
                            <span data-i18n="windNorth">–° (0¬∞)</span>
                            <span id="windDirectionValue" class="font-semibold text-forest-700 dark:text-forest-400">–í
                                (90¬∞)</span>
                            <span data-i18n="windSouth">–Æ (180¬∞)</span>
                        </div>
                    </div>

                    <!-- Section Divider -->
                    <div class="border-t border-gray-300 my-2"></div>
                    <div class="text-xs font-bold text-gray-500 uppercase tracking-wide mb-2" data-i18n="phytoSection">
                        –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–æ–≤</div>

                    <!-- Base Radius -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <i class="fas fa-arrows-alt text-forest-600"></i> <span data-i18n="baseRadius">–ë–∞–∑–æ–≤—ã–π
                                —Ä–∞–¥–∏—É—Å –¥–µ–π—Å—Ç–≤–∏—è</span>
                        </label>
                        <input type="range" id="baseRadius" min="20" max="100" value="50" step="5"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-forest-600" />
                        <div class="flex justify-between text-xs text-gray-600 mt-1">
                            <span>20 –º</span>
                            <span id="baseRadiusValue" class="font-semibold text-forest-700 dark:text-forest-400">50
                                –º</span>
                            <span>100 –º</span>
                        </div>
                    </div>

                    <!-- Array Synergy -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <i class="fas fa-layer-group text-forest-600"></i> <span data-i18n="arrayEffect">–≠—Ñ—Ñ–µ–∫—Ç
                                –º–∞—Å—Å–∏–≤–∞</span>
                        </label>
                        <input type="range" id="arraySynergy" min="100" max="200" value="150" step="10"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-forest-600" />
                        <div class="flex justify-between text-xs text-gray-600 mt-1">
                            <span data-i18n="effectWeak">–°–ª–∞–±—ã–π</span>
                            <span id="arraySynergyValue"
                                class="font-semibold text-forest-700 dark:text-forest-400">150%</span>
                            <span data-i18n="effectStrong">–°–∏–ª—å–Ω—ã–π</span>
                        </div>
                        <p class="text-xs text-gray-600 mt-1" data-i18n="arrayEffectDesc">–£—Å–∏–ª–µ–Ω–∏–µ –ø—Ä–∏ –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏–∏ –∑–æ–Ω
                            –¥–µ—Ä–µ–≤—å–µ–≤</p>
                    </div>

                    <!-- Section Divider -->
                    <div class="border-t border-gray-300 my-2"></div>
                    <div class="text-xs font-bold text-gray-500 uppercase tracking-wide mb-2" data-i18n="visualSection">
                        –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è</div>

                    <!-- Layer Opacity Control -->
                    <div>
                        <label class="block text-sm font-semibold text-gray-700 mb-2">
                            <i class="fas fa-adjust text-forest-600"></i> <span data-i18n="layerOpacity">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
                                —Å–ª–æ—è</span>
                        </label>
                        <input type="range" id="layerOpacity" min="0" max="100" value="30" step="5"
                            class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-forest-600" />
                        <div class="flex justify-between text-xs text-gray-600 mt-1">
                            <span data-i18n="opacityTransparent">–ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π</span>
                            <span id="layerOpacityValue"
                                class="font-semibold text-forest-700 dark:text-forest-400">30%</span>
                            <span data-i18n="opacityOpaque">–ù–µ–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π</span>
                        </div>
                        <p class="text-xs text-gray-600 mt-1" data-i18n="opacityDesc">–í–∏–¥–∏–º–æ—Å—Ç—å –∑–µ–ª–µ–Ω–æ–≥–æ —Å–ª–æ—è —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–æ–≤
                        </p>
                    </div>

                    <!-- Particle Animation Toggle -->
                    <div>
                        <label class="flex items-center justify-between">
                            <span class="text-sm font-semibold text-gray-700" data-i18n="particles">
                                <i class="fas fa-atom text-forest-600"></i> –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü
                            </span>
                            <input type="checkbox" id="particleToggle" checked=""
                                class="w-5 h-5 text-forest-600 rounded focus:ring-2 focus:ring-forest-500" />
                        </label>
                        <p class="text-xs text-gray-600 mt-1" data-i18n="particlesDesc">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –¥–≤–∏–∂–µ–Ω–∏–µ –∏ –∏—Å–ø–∞—Ä–µ–Ω–∏–µ
                            —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–æ–≤</p>
                    </div>



                    <!-- Section Divider -->
                    <div class="border-t border-gray-300 my-2"></div>
                    <div class="text-xs font-bold text-gray-500 uppercase tracking-wide mb-2"
                        data-i18n="actionsSection">–î–µ–π—Å—Ç–≤–∏—è</div>

                    <!-- Action Buttons -->
                    <div class="flex gap-2">
                        <button id="clearBtn"
                            class="flex-1 bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg text-sm font-semibold transition-colors flex items-center justify-center gap-2">
                            <i class="fas fa-trash"></i>
                            <span data-i18n="btnClear">–û—á–∏—Å—Ç–∏—Ç—å</span>
                        </button>
                        <button id="updateBtn"
                            class="flex-1 bg-forest-600 hover:bg-forest-700 text-white px-4 py-2 rounded-lg text-sm font-semibold transition-colors flex items-center justify-center gap-2">
                            <i class="fas fa-sync"></i>
                            <span data-i18n="btnUpdate">–û–±–Ω–æ–≤–∏—Ç—å</span>
                        </button>
                    </div>

                    <!-- Color Analysis Button -->
                    <div>
                        <button id="analyzeBtn"
                            class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-semibold transition-colors flex items-center justify-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed">
                            <i class="fas fa-microscope"></i>
                            <span data-i18n="btnAnalyze">–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ–±–ª–∞—Å—Ç—å</span>
                        </button>
                        <p class="text-xs text-gray-600 mt-1" data-i18n="analyzeDesc">–ê–Ω–∞–ª–∏–∑ –∑–µ–ª–µ–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π –Ω–∞
                            —Å–ø—É—Ç–Ω–∏–∫–æ–≤–æ–º —Å–Ω–∏–º–∫–µ</p>
                    </div>

                    <!-- Statistics -->
                    <div id="stats" class="bg-gray-50 dark:bg-gray-700/50 rounded-lg p-3 space-y-2 hidden">
                        <h3 class="font-semibold text-gray-800 dark:text-gray-200 text-sm mb-2">
                            <i class="fas fa-chart-bar text-forest-600 dark:text-forest-400"></i> <span
                                data-i18n="statsTitle">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</span>
                        </h3>
                        <div class="grid grid-cols-2 gap-2 text-xs">
                            <div class="bg-white dark:bg-gray-800 p-2 rounded">
                                <div class="text-gray-600 dark:text-gray-400" data-i18n="statArea">–ü–ª–æ—â–∞–¥—å</div>
                                <div id="areaValue" class="font-bold text-forest-700 dark:text-forest-400">-</div>
                            </div>
                            <div class="bg-white dark:bg-gray-800 p-2 rounded">
                                <div class="text-gray-600 dark:text-gray-400" data-i18n="statTrees">–î–µ—Ä–µ–≤—å–µ–≤</div>
                                <div id="treesValue" class="font-bold text-forest-700 dark:text-forest-400">-</div>
                            </div>
                            <div class="bg-white dark:bg-gray-800 p-2 rounded">
                                <div class="text-gray-600 dark:text-gray-400" data-i18n="statRadius">–ú–∞–∫—Å. —Ä–∞–¥–∏—É—Å</div>
                                <div id="maxRadiusValue" class="font-bold text-forest-700 dark:text-forest-400">-</div>
                            </div>
                            <div class="bg-white dark:bg-gray-800 p-2 rounded">
                                <div class="text-gray-600 dark:text-gray-400" data-i18n="statMultiplier">–ú–Ω–æ–∂–∏—Ç–µ–ª—å</div>
                                <div id="multiplierValue" class="font-bold text-forest-700 dark:text-forest-400">-</div>
                            </div>
                        </div>
                    </div>

                    <!-- Analysis Results -->
                    <div id="analysisResults"
                        class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800/50 rounded-lg p-3 space-y-2 hidden">
                        <h3 class="font-semibold text-gray-800 dark:text-gray-200 text-sm mb-2 flex items-center gap-2">
                            <i class="fas fa-chart-pie text-blue-600 dark:text-blue-400"></i> <span
                                data-i18n="resultsTitle">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã
                                –∞–Ω–∞–ª–∏–∑–∞</span>
                        </h3>
                        <div class="grid grid-cols-2 gap-2 text-xs">
                            <div class="bg-white dark:bg-gray-800 p-2 rounded">
                                <div class="text-gray-600 dark:text-gray-400" data-i18n="resGreenPixels">–ó–µ–ª–µ–Ω—ã–µ –ø–∏–∫—Å–µ–ª–∏
                                </div>
                                <div id="greenPixelsValue" class="font-bold text-green-700 dark:text-green-400">-</div>
                            </div>
                            <div class="bg-white dark:bg-gray-800 p-2 rounded">
                                <div class="text-gray-600 dark:text-gray-400" data-i18n="resCoverage">–ü–æ–∫—Ä—ã—Ç–∏–µ</div>
                                <div id="coverageValue" class="font-bold text-green-700 dark:text-green-400">-</div>
                            </div>
                            <div class="bg-white dark:bg-gray-800 p-2 rounded col-span-2">
                                <div class="text-gray-600 dark:text-gray-400" data-i18n="resEstTrees">–û—Ü–µ–Ω–∫–∞ –¥–µ—Ä–µ–≤—å–µ–≤
                                </div>
                                <div id="estimatedTreesValue" class="font-bold text-forest-700 dark:text-forest-400">-
                                </div>
                            </div>
                        </div>
                        <div class="text-xs text-gray-600 mt-2" data-i18n="resInfo">
                            <i class="fas fa-info-circle"></i> –ê–Ω–∞–ª–∏–∑ –æ—Å–Ω–æ–≤–∞–Ω –Ω–∞ —Ü–≤–µ—Ç–æ–≤–æ–º —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–∏ –∑–µ–ª–µ–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π
                        </div>
                    </div>

                    <!-- Legend -->
                    <div class="bg-gray-50 dark:bg-gray-700/50 rounded-lg p-3">
                        <h3 class="font-semibold text-gray-800 dark:text-gray-200 text-sm mb-2">
                            <i class="fas fa-palette text-forest-600 dark:text-forest-400"></i> <span
                                data-i18n="legendTitle">–õ–µ–≥–µ–Ω–¥–∞</span>
                        </h3>
                        <div class="space-y-2">
                            <div class="flex items-center gap-2 text-xs">
                                <div
                                    class="w-4 h-4 rounded-full bg-forest-700 border-2 border-white dark:border-gray-600">
                                </div>
                                <span class="text-gray-700 dark:text-gray-300" data-i18n="legendSpruce">–ï–ª—å
                                    (–¥–µ—Ä–µ–≤–æ)</span>
                            </div>
                            <div>
                                <div class="text-xs text-gray-700 dark:text-gray-300 mb-1"
                                    data-i18n="legendConcentration">–ö–æ–Ω—Ü–µ–Ω—Ç—Ä–∞—Ü–∏—è
                                    —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–æ–≤:</div>
                                <div
                                    class="gradient-bar h-6 rounded flex items-center justify-between px-2 text-[10px] text-white font-semibold">
                                    <span class="drop-shadow" data-i18n="legendLow">–ù–∏–∑–∫–∞—è</span>
                                    <span class="drop-shadow" data-i18n="legendHigh">–í—ã—Å–æ–∫–∞—è</span>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <!-- Map Container -->
    <div id="map"></div>



    <!-- Particle Animation Canvas -->
    <canvas id="particleCanvas"></canvas>

    <!-- Attribution -->
    <div
        class="absolute bottom-4 left-4 z-[1000] bg-white/90 backdrop-blur-sm px-3 py-2 rounded-lg shadow-lg text-xs text-gray-600">
        <i class="fas fa-leaf text-forest-600"></i> <span data-i18n="attribution">–ù–∞—É—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Å–Ω–æ–≤–∞–Ω—ã –Ω–∞
            –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è—Ö —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
            —Ö–≤–æ–π–Ω—ã—Ö</span>
    </div>

    <script>
        // Initialize map centered on Zyryanovsk, Kazakhstan
        const map = L.map('map').setView([49.7447, 84.2697], 13);

        // Base layers
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        });

        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles ¬© Esri',
            maxZoom: 19
        });

        // Add default layer
        satelliteLayer.addTo(map);



        // Feature group for drawn items
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

        // Drawing control
        const drawControl = new L.Control.Draw({
            position: 'topleft',
            draw: {
                polygon: {
                    allowIntersection: true,
                    showArea: true,
                    shapeOptions: {
                        color: '#15803d',
                        weight: 3,
                        fillOpacity: 0.1
                    }
                },
                polyline: false,
                rectangle: false,
                circle: false,
                marker: false,
                circlemarker: false
            },
            edit: {
                featureGroup: drawnItems,
                remove: true
            }
        });
        map.addControl(drawControl);

        // Store trees and phytoncide circles
        let trees = [];
        let phytoncideCircles = [];
        let currentPolygon = null;

        // Get DOM elements
        const treeDensitySlider = document.getElementById('treeDensity');
        const treeDensityValue = document.getElementById('treeDensityValue');
        const seasonSelect = document.getElementById('season');
        const timeOfDaySelect = document.getElementById('timeOfDay');
        const weatherSelect = document.getElementById('weather');
        const windSpeedSlider = document.getElementById('windSpeed');
        const windSpeedValue = document.getElementById('windSpeedValue');
        const baseRadiusSlider = document.getElementById('baseRadius');
        const baseRadiusValue = document.getElementById('baseRadiusValue');
        const arraySynergySlider = document.getElementById('arraySynergy');
        const arraySynergyValue = document.getElementById('arraySynergyValue');
        const clearBtn = document.getElementById('clearBtn');
        const updateBtn = document.getElementById('updateBtn');
        const stats = document.getElementById('stats');
        const workModeSelect = document.getElementById('workMode');
        const instructionText = document.getElementById('instructionText');
        const mapLayerSelect = document.getElementById('mapLayer');
        const windDirectionSlider = document.getElementById('windDirection');
        const windDirectionValue = document.getElementById('windDirectionValue');
        const particleToggle = document.getElementById('particleToggle');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const layerOpacitySlider = document.getElementById('layerOpacity');
        const layerOpacityValue = document.getElementById('layerOpacityValue');


        // Setup canvases early so they can be used in event handlers
        const particleCanvas = document.getElementById('particleCanvas');
        const ctx = particleCanvas.getContext('2d');

        let manualMode = false;
        let isParticleAnimationEnabled = true;
        let layerOpacityMultiplier = 0.3; // Default 30%
        let particles = [];

        // Resize canvases to match map
        function resizeCanvas() {
            particleCanvas.width = map.getContainer().offsetWidth;
            particleCanvas.height = map.getContainer().offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        map.on('move', resizeCanvas);

        // Update slider displays
        treeDensitySlider.addEventListener('input', (e) => {
            treeDensityValue.textContent = e.target.value + '/–≥–∞';
            // Auto-regenerate trees when density changes
            if (currentPolygon && trees.length > 0) {
                generateTrees(currentPolygon);
            }
        });

        windSpeedSlider.addEventListener('input', (e) => {
            windSpeedValue.textContent = e.target.value + ' –º/—Å';
        });

        baseRadiusSlider.addEventListener('input', (e) => {
            baseRadiusValue.textContent = e.target.value + ' –º';
        });

        arraySynergySlider.addEventListener('input', (e) => {
            arraySynergyValue.textContent = e.target.value + '%';
        });

        windDirectionSlider.addEventListener('input', (e) => {
            const degrees = parseInt(e.target.value);
            const currentLang = localStorage.getItem('language') || 'ru';
            const t = translations[currentLang] || translations.ru;

            const directions = {
                0: t.windNorth || '–°',
                45: t.windNorthEast || '–°–í',
                90: t.windEast || '–í',
                135: t.windSouthEast || '–Æ–í',
                180: t.windSouth || '–Æ',
                225: t.windSouthWest || '–Æ–ó',
                270: t.windWest || '–ó',
                315: t.windNorthWest || '–°–ó'
            };
            const nearest = Math.round(degrees / 45) * 45;
            const dirLabel = directions[nearest % 360] || (t.windNorth || '–°');
            windDirectionValue.textContent = `${dirLabel} (${degrees}¬∞)`;
        });

        // Layer opacity control
        layerOpacitySlider.addEventListener('input', (e) => {
            layerOpacityMultiplier = parseInt(e.target.value) / 100;
            layerOpacityValue.textContent = e.target.value + '%';
            if (trees.length > 0) {
                updatePhytoncideVisualization();
            }
        });





        // Work mode change
        workModeSelect.addEventListener('change', (e) => {
            manualMode = e.target.value === 'manual';
            updateInstructionText();
            if (manualMode) {
                drawControl.remove();
                map.on('click', onMapClick);
            } else {
                map.addControl(drawControl);
                map.off('click', onMapClick);
            }
        });

        // Function to update instruction text based on mode and language
        function updateInstructionText() {
            const currentLang = localStorage.getItem('language') || 'ru';
            const t = translations[currentLang] || translations.ru;

            if (manualMode) {
                instructionText.innerHTML = t.instructionManual || '–ö–ª–∏–∫–∞–π—Ç–µ –ø–æ –∫–∞—Ä—Ç–µ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –¥–µ—Ä–µ–≤—å–µ–≤. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–ø—É—Ç–Ω–∏–∫–æ–≤—ã–π —Å–ª–æ–π –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö –ª–µ—Å–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤.';
            } else {
                instructionText.innerHTML = (t.instructionPolygon || '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç–µ, –∑–∞—Ç–µ–º –∫–ª–∏–∫–∞–π—Ç–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª–∏–≥–æ–Ω–∞ –ª–µ—Å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –∑–∞–≤–µ—Ä—à–∞–µ—Ç —Ä–∏—Å–æ–≤–∞–Ω–∏–µ.').replace('<i class="fas fa-draw-polygon text-xs"></i>', '').trim();
                // If the translation doesn't include the icon, we might want to add it back if we want it there
                instructionText.innerHTML = (t.instructionBoxTitle || '–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:') + ' ' + (t.instructionBoxText || '–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç—É...');
            }
        }

        // Map layer change
        mapLayerSelect.addEventListener('change', (e) => {
            if (e.target.value === 'satellite') {
                map.removeLayer(osmLayer);
                map.addLayer(satelliteLayer);
            } else {
                map.removeLayer(satelliteLayer);
                map.addLayer(osmLayer);
            }
        });

        // Particle animation toggle
        particleToggle.addEventListener('change', (e) => {
            isParticleAnimationEnabled = e.target.checked;
            if (!isParticleAnimationEnabled) {
                particles = [];
            }
        });

        // Manual tree placement
        function onMapClick(e) {
            if (!manualMode) return;

            const treeMarker = L.circleMarker(e.latlng, {
                radius: 8,
                fillColor: '#2d5016',
                color: '#ffffff',
                weight: 3,
                opacity: 1,
                fillOpacity: 1,
                className: 'tree-marker'
            }).addTo(map);

            trees.push({
                marker: treeMarker,
                position: e.latlng
            });

            updatePhytoncideVisualization();
            updateManualStatistics();
        }

        // Update statistics for manual mode
        function updateManualStatistics() {
            if (trees.length === 0) {
                stats.classList.add('hidden');
                return;
            }

            stats.classList.remove('hidden');
            document.getElementById('areaValue').textContent = 'N/A';
            document.getElementById('treesValue').textContent = trees.length;

            const baseRadius = parseInt(baseRadiusSlider.value);
            const envMultiplier = getEnvironmentalMultiplier();
            const effectiveRadius = baseRadius * envMultiplier;

            document.getElementById('maxRadiusValue').textContent = effectiveRadius.toFixed(0) + ' –º';
            document.getElementById('multiplierValue').textContent = envMultiplier.toFixed(2) + 'x';
        }

        // Calculate environmental multiplier
        function getEnvironmentalMultiplier() {
            let multiplier = 1.0;

            // Season effect
            const seasonEffects = {
                spring: 1.2,
                summer: 1.5,
                autumn: 0.8,
                winter: 0.3
            };
            multiplier *= seasonEffects[seasonSelect.value] || 1.0;

            // Time of day effect
            const timeEffects = {
                morning: 1.1,
                day: 1.3,
                evening: 0.9,
                night: 0.6
            };
            multiplier *= timeEffects[timeOfDaySelect.value] || 1.0;

            // Weather effect
            const weatherEffects = {
                sunny: 1.3,
                cloudy: 1.0,
                rainy: 0.6,
                foggy: 0.7
            };
            multiplier *= weatherEffects[weatherSelect.value] || 1.0;

            // Wind effect (optimal around 2-4 m/s)
            const windSpeed = parseFloat(windSpeedSlider.value);
            if (windSpeed < 2) {
                multiplier *= 0.7 + (windSpeed * 0.15); // 0.7 to 1.0
            } else if (windSpeed <= 4) {
                multiplier *= 1.0 + ((windSpeed - 2) * 0.1); // 1.0 to 1.2
            } else {
                multiplier *= 1.2 - ((windSpeed - 4) * 0.05); // 1.2 to 0.9
            }

            return multiplier;
        }

        // Generate random point inside polygon
        function randomPointInPolygon(polygon) {
            const bounds = polygon.getBounds();
            let point;
            let attempts = 0;

            do {
                const lat = bounds.getSouth() + Math.random() * (bounds.getNorth() - bounds.getSouth());
                const lng = bounds.getWest() + Math.random() * (bounds.getEast() - bounds.getWest());
                point = L.latLng(lat, lng);
                attempts++;
            } while (!isPointInPolygon(point, polygon) && attempts < 100);

            return isPointInPolygon(point, polygon) ? point : null;
        }

        // Check if point is inside polygon
        function isPointInPolygon(point, polygon) {
            const latlngs = polygon.getLatLngs()[0];
            let inside = false;

            for (let i = 0, j = latlngs.length - 1; i < latlngs.length; j = i++) {
                const xi = latlngs[i].lat, yi = latlngs[i].lng;
                const xj = latlngs[j].lat, yj = latlngs[j].lng;

                const intersect = ((yi > point.lng) !== (yj > point.lng))
                    && (point.lat < (xj - xi) * (point.lng - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }

            return inside;
        }

        // Calculate polygon area in hectares
        function getPolygonArea(polygon) {
            const latlngs = polygon.getLatLngs()[0];
            let area = 0;

            for (let i = 0; i < latlngs.length; i++) {
                const j = (i + 1) % latlngs.length;
                area += latlngs[i].lng * latlngs[j].lat;
                area -= latlngs[j].lng * latlngs[i].lat;
            }

            area = Math.abs(area / 2);

            // Convert to square meters (approximate)
            const metersPerDegree = 111320;
            const areaSqMeters = area * metersPerDegree * metersPerDegree;

            // Convert to hectares
            return areaSqMeters / 10000;
        }

        // Generate trees in polygon
        function generateTrees(polygon) {
            clearTrees();
            currentPolygon = polygon;

            const area = getPolygonArea(polygon);
            const density = parseInt(treeDensitySlider.value);
            const numTrees = Math.round(area * density);

            for (let i = 0; i < numTrees; i++) {
                const point = randomPointInPolygon(polygon);
                if (point) {
                    const treeMarker = L.circleMarker(point, {
                        radius: 8,
                        fillColor: '#2d5016',
                        color: '#ffffff',
                        weight: 3,
                        opacity: 1,
                        fillOpacity: 1,
                        className: 'tree-marker'
                    }).addTo(map);

                    trees.push({
                        marker: treeMarker,
                        position: point
                    });
                }
            }

            updatePhytoncideVisualization();
            updateStatistics(area, numTrees);
        }

        // Clear all trees and circles
        function clearTrees() {
            trees.forEach(tree => map.removeLayer(tree.marker));
            trees = [];
            phytoncideCircles.forEach(circle => map.removeLayer(circle));
            phytoncideCircles = [];
        }

        // Update phytoncide visualization
        function updatePhytoncideVisualization() {
            // Clear existing circles
            phytoncideCircles.forEach(circle => map.removeLayer(circle));
            phytoncideCircles = [];

            if (trees.length === 0) return;

            const baseRadius = parseInt(baseRadiusSlider.value);
            const envMultiplier = getEnvironmentalMultiplier();
            const arraySynergy = parseInt(arraySynergySlider.value) / 100;

            // Create a concentration map
            const concentrationMap = new Map();
            const gridSize = 10; // meters

            // Calculate concentration for each tree
            trees.forEach(tree => {
                const effectiveRadius = baseRadius * envMultiplier;

                // Create multiple circles with decreasing opacity for gradient effect
                const numRings = 8;
                for (let i = numRings; i >= 1; i--) {
                    const ringRadius = (effectiveRadius * i) / numRings;
                    const concentration = (i / numRings);

                    // Check for overlaps with other trees
                    let overlapBonus = 1.0;
                    trees.forEach(otherTree => {
                        if (otherTree !== tree) {
                            const distance = map.distance(tree.position, otherTree.position);
                            if (distance < effectiveRadius * 2) {
                                const overlapFactor = 1 - (distance / (effectiveRadius * 2));
                                overlapBonus += overlapFactor * (arraySynergy - 1);
                            }
                        }
                    });

                    const finalConcentration = Math.min(concentration * overlapBonus, 1.0);
                    // –ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å: 100% —Å–ª–∞–π–¥–µ—Ä–∞ = ~20% —Ä–µ–∞–ª—å–Ω–æ–π –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
                    const baseOpacity = 0.004 + (finalConcentration * 0.012); // –£–º–µ–Ω—å—à–µ–Ω–æ –¥–ª—è –≤–∏–¥–∏–º–æ—Å—Ç–∏ –∑–¥–∞–Ω–∏–π
                    const opacity = baseOpacity * layerOpacityMultiplier;

                    const circle = L.circle(tree.position, {
                        radius: ringRadius,
                        fillColor: '#00FF00', // –Ø—Ä–∫–∏–π –∑–µ–ª–µ–Ω—ã–π –±–µ–∑ —Ç–µ–º–Ω–æ–π —Ç–µ–Ω–∏
                        color: 'transparent',
                        fillOpacity: opacity,
                        weight: 0
                    }).addTo(map);

                    phytoncideCircles.push(circle);
                }
            });
        }

        // Update statistics panel
        function updateStatistics(area, numTrees) {
            stats.classList.remove('hidden');

            document.getElementById('areaValue').textContent = area.toFixed(2) + ' –≥–∞';
            document.getElementById('treesValue').textContent = numTrees;

            const baseRadius = parseInt(baseRadiusSlider.value);
            const envMultiplier = getEnvironmentalMultiplier();
            const effectiveRadius = baseRadius * envMultiplier;

            document.getElementById('maxRadiusValue').textContent = effectiveRadius.toFixed(0) + ' –º';
            document.getElementById('multiplierValue').textContent = envMultiplier.toFixed(2) + 'x';
        }

        // Handle polygon creation
        map.on(L.Draw.Event.CREATED, function (e) {
            const layer = e.layer;
            drawnItems.addLayer(layer);
            generateTrees(layer);
        });

        // Handle polygon deletion
        map.on(L.Draw.Event.DELETED, function (e) {
            clearTrees();
            stats.classList.add('hidden');
            currentPolygon = null;
        });

        // Clear button
        clearBtn.addEventListener('click', function () {
            drawnItems.clearLayers();
            clearTrees();
            stats.classList.add('hidden');
            currentPolygon = null;
        });

        // Update button
        updateBtn.addEventListener('click', function () {
            if (currentPolygon) {
                generateTrees(currentPolygon);
            }
        });

        // Listen to parameter changes for live update
        [seasonSelect, timeOfDaySelect, weatherSelect, windSpeedSlider, baseRadiusSlider, arraySynergySlider, windDirectionSlider].forEach(element => {
            element.addEventListener('change', function () {
                if (trees.length > 0) {
                    updatePhytoncideVisualization();
                    if (currentPolygon) {
                        const area = getPolygonArea(currentPolygon);
                        updateStatistics(area, trees.length);
                    } else {
                        updateManualStatistics();
                    }
                }
            });

            element.addEventListener('input', function () {
                if (trees.length > 0 && (element === windSpeedSlider || element === baseRadiusSlider || element === arraySynergySlider || element === windDirectionSlider)) {
                    updatePhytoncideVisualization();
                    if (currentPolygon) {
                        const area = getPolygonArea(currentPolygon);
                        updateStatistics(area, trees.length);
                    } else {
                        updateManualStatistics();
                    }
                }
            });
        });

        // ====== PARTICLE ANIMATION SYSTEM ======

        // Particle class
        class Particle {
            constructor(tree) {
                this.tree = tree;
                const point = map.latLngToContainerPoint(tree.position);
                this.x = point.x;
                this.y = point.y;

                // –ù–∞—á–∞–ª—å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ –≤–µ—Ç—Ä–µ —Å —Å–ª—É—á–∞–π–Ω—ã–º –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ–º
                const windDir = parseInt(windDirectionSlider.value) * Math.PI / 180;
                const windSpeed = parseFloat(windSpeedSlider.value);

                // –°–ª—É—á–∞–π–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –æ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–µ—Ç—Ä–∞ (¬±60 –≥—Ä–∞–¥—É—Å–æ–≤)
                const randomAngleOffset = (Math.random() - 0.5) * (Math.PI / 1.5); // ¬±60¬∞
                const particleAngle = windDir + randomAngleOffset;

                // –°–∫–æ—Ä–æ—Å—Ç—å —Å —É—á–µ—Ç–æ–º –≤–µ—Ç—Ä–∞ –∏ —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏
                const baseSpeed = 0.2 + Math.random() * 0.4;
                const windInfluence = windSpeed * 0.1; // –í–ª–∏—è–Ω–∏–µ –≤–µ—Ç—Ä–∞ –Ω–∞ –Ω–∞—á–∞–ª—å–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å
                const speed = baseSpeed + windInfluence;

                this.vx = Math.cos(particleAngle) * speed;
                this.vy = Math.sin(particleAngle) * speed;

                this.life = 1.0; // 1.0 = fully alive, 0.0 = dead
                this.maxLife = 300 + Math.random() * 400; // –£–≤–µ–ª–∏—á–µ–Ω–æ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏ –¥–ª—è –¥–æ–ª–≥–æ–≥–æ –ø–æ–ª–µ—Ç–∞
                this.age = 0;
                this.size = 3 + Math.random() * 3; // –£–≤–µ–ª–∏—á–µ–Ω —Ä–∞–∑–º–µ—Ä –¥–ª—è –∑–∞–º–µ—Ç–Ω–æ—Å—Ç–∏ (3-6 –ø–∏–∫—Å–µ–ª–µ–π)
                this.initialSize = this.size;
            }

            update() {
                // Wind influence (—É–º–µ–Ω—å—à–µ–Ω–æ)
                const windSpeed = parseFloat(windSpeedSlider.value) * 0.08;
                const windDir = parseInt(windDirectionSlider.value) * Math.PI / 180;
                const windX = Math.cos(windDir) * windSpeed;
                const windY = Math.sin(windDir) * windSpeed;

                // Apply wind (–ø–ª–∞–≤–Ω–µ–µ)
                this.vx += windX * 0.02;
                this.vy += windY * 0.02;

                // –û—á–µ–Ω—å —Å–ª–∞–±–∞—è –ø–ª–∞–≤—É—á–µ—Å—Ç—å (–ø–æ—á—Ç–∏ –Ω–µ –≤–ª–∏—è–µ—Ç)
                this.vy -= 0.005; // –£–º–µ–Ω—å—à–µ–Ω–æ —Å 0.02 –¥–æ 0.005

                // Air resistance (–±–æ–ª–µ–µ —Å–∏–ª—å–Ω–æ–µ –∑–∞–º–µ–¥–ª–µ–Ω–∏–µ)
                this.vx *= 0.985;
                this.vy *= 0.985;

                // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–±–æ–ª—å—à—É—é —Ç—É—Ä–±—É–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å (—É–º–µ–Ω—å—à–µ–Ω–∞)
                this.vx += (Math.random() - 0.5) * 0.05;
                this.vy += (Math.random() - 0.5) * 0.05;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Update life
                this.age++;
                this.life = 1.0 - (this.age / this.maxLife);

                // Environmental decay rate
                const envMultiplier = getEnvironmentalMultiplier();
                const decayRate = 2.0 / envMultiplier; // Higher multiplier = slower decay
                this.life -= decayRate / this.maxLife;
            }

            draw() {
                const opacity = Math.max(0, this.life * 1.0); // –£–≤–µ–ª–∏—á–µ–Ω–∞ –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
                const size = this.initialSize * (0.5 + this.life * 0.5); // –£–º–µ–Ω—å—à–∞–µ—Ç—Å—è —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º

                // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è –±–æ–ª–µ–µ –∫—Ä–∞—Å–∏–≤–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size);
                gradient.addColorStop(0, `rgba(200, 255, 200, ${opacity})`);
                gradient.addColorStop(0.5, `rgba(150, 255, 150, ${opacity * 0.8})`);
                gradient.addColorStop(1, `rgba(100, 200, 100, ${opacity * 0.3})`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            isDead() {
                return this.life <= 0 || this.age >= this.maxLife;
            }
        }


        // Generate particles from trees
        function generateParticles() {
            if (!isParticleAnimationEnabled || trees.length === 0) return;

            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–∏—Ü –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            const maxParticlesPerTree = 2;

            trees.forEach(tree => {
                // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —á–∞—Å—Ç–∏—Ü—ã –æ—Ç —ç—Ç–æ–≥–æ –¥–µ—Ä–µ–≤–∞
                const treeParticles = particles.filter(p => p.tree === tree).length;

                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –º–µ–Ω—å—à–µ –º–∞–∫—Å–∏–º—É–º–∞
                if (treeParticles < maxParticlesPerTree && Math.random() < 0.15) {
                    particles.push(new Particle(tree));
                }
            });

            // Limit total particles for performance (—É–º–µ–Ω—å—à–µ–Ω –ª–∏–º–∏—Ç)
            const maxTotalParticles = Math.min(trees.length * 2, 500);
            if (particles.length > maxTotalParticles) {
                particles = particles.slice(-maxTotalParticles);
            }
        }



        // Animation loop
        function animate() {
            // Clear canvases
            ctx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);

            // Generate and update particles
            // Generate and update particles
            if (isParticleAnimationEnabled) {
                // Update tree positions on canvas (in case map moved)
                particles.forEach(particle => {
                    const point = map.latLngToContainerPoint(particle.tree.position);
                    const baseX = point.x;
                    const baseY = point.y;

                    // Keep relative position to tree
                    if (particle.age === 0) {
                        particle.x = baseX;
                        particle.y = baseY;
                    }
                });

                generateParticles();

                particles = particles.filter(p => !p.isDead());
                particles.forEach(p => {
                    p.update();
                    p.draw();
                });
            }

            requestAnimationFrame(animate);
        }

        // Start animation
        animate();

        // Update particle positions when map moves
        map.on('move', () => {
            // Particles will auto-adjust based on tree positions in next frame
        });

        // ====== COLOR ANALYSIS SYSTEM ======

        // Check if green color (vegetation)
        function isGreenPixel(r, g, b) {
            // Convert to HSL for better color detection
            const rNorm = r / 255;
            const gNorm = g / 255;
            const bNorm = b / 255;

            const max = Math.max(rNorm, gNorm, bNorm);
            const min = Math.min(rNorm, gNorm, bNorm);
            const delta = max - min;

            // Calculate hue
            let h = 0;
            if (delta !== 0) {
                if (max === rNorm) {
                    h = ((gNorm - bNorm) / delta) % 6;
                } else if (max === gNorm) {
                    h = (bNorm - rNorm) / delta + 2;
                } else {
                    h = (rNorm - gNorm) / delta + 4;
                }
                h = Math.round(h * 60);
                if (h < 0) h += 360;
            }

            // Calculate saturation
            const l = (max + min) / 2;
            const s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));

            // EXTREMELY STRICT green detection for vegetation ONLY
            // This must exclude: roads (gray), buildings (various), dirt (brown), concrete, etc.

            // 1. Hue check: ONLY pure vegetation green (90-130 degrees)
            // Narrower range to exclude yellow-green grass and cyan water reflections
            const validHue = (h >= 90 && h <= 130);

            // 2. Saturation check: Must be VERY saturated (at least 30%)
            // Roads and buildings are typically desaturated (gray/brown)
            const validSaturation = (s >= 0.30);

            // 3. Lightness check: Medium range only (25-60%)
            // Excludes: dark shadows, bright concrete, light buildings
            const validLightness = (l >= 0.25 && l <= 0.60);

            // 4. Green channel MUST be VERY dominant
            // Green should be at least 30% higher than red AND 20% higher than blue
            const greenVeryDominant = g > (r * 1.3) && g > (b * 1.2);

            // 5. Absolute green value check
            // Green channel must be reasonably bright (at least 80/255)
            const greenBrightEnough = g >= 80;

            // 6. Color difference check - must have significant color variation
            // This excludes gray roads where R‚âàG‚âàB
            const colorDiff = Math.abs(r - g) + Math.abs(g - b) + Math.abs(r - b);
            const hasSignificantColor = colorDiff > 50; // Increased threshold

            // 7. NOT gray check - ensure it's not a gray/neutral color
            const maxDiff = Math.max(Math.abs(r - g), Math.abs(g - b), Math.abs(r - b));
            const notGray = maxDiff > 30;

            // ALL conditions must be true
            return validHue && validSaturation && validLightness &&
                greenVeryDominant && greenBrightEnough &&
                hasSignificantColor && notGray;

        }

        // Analyze polygon area for green pixels using html2canvas
        async function analyzePolygonArea() {
            const currentLang = localStorage.getItem('language') || 'ru';
            const t = translations[currentLang] || translations.ru;

            if (!currentPolygon && trees.length === 0) {
                alert(t.alertDrawFirst || '–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ä–∏—Å—É–π—Ç–µ –æ–±–ª–∞—Å—Ç—å –∏–ª–∏ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç–µ –¥–µ—Ä–µ–≤—å—è!');
                return;
            }

            // Disable button and show loading state
            analyzeBtn.disabled = true;
            analyzeBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${t.btnAnalyzing || '–ê–Ω–∞–ª–∏–∑...'}`;

            try {
                // Get polygon bounds or create bounds from trees
                let bounds;
                if (currentPolygon) {
                    bounds = currentPolygon.getBounds();
                } else {
                    // Create bounds from manually placed trees
                    const lats = trees.map(t => t.position.lat);
                    const lngs = trees.map(t => t.position.lng);
                    bounds = L.latLngBounds(
                        [Math.min(...lats), Math.min(...lngs)],
                        [Math.max(...lats), Math.max(...lngs)]
                    );
                    // Expand bounds a bit
                    bounds = bounds.pad(0.2);
                }

                // Get pixel bounds on screen
                const northWest = map.latLngToContainerPoint(bounds.getNorthWest());
                const southEast = map.latLngToContainerPoint(bounds.getSouthEast());

                const width = Math.abs(southEast.x - northWest.x);
                const height = Math.abs(southEast.y - northWest.y);
                const x = Math.min(northWest.x, southEast.x);
                const y = Math.min(northWest.y, southEast.y);

                // Hide control panel temporarily for cleaner capture
                const controlPanel = document.getElementById('controlPanel');
                const wasVisible = !controlPanel.classList.contains('translate-y-full');
                if (wasVisible) {
                    controlPanel.classList.add('translate-y-full');
                }

                // Wait a bit for animation
                await new Promise(resolve => setTimeout(resolve, 350));

                // Capture the map using html2canvas
                const mapContainer = document.getElementById('map');
                const canvas = await html2canvas(mapContainer, {
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: null,
                    logging: false,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    scale: 1 // Lower scale for better performance
                });

                // Restore control panel
                if (wasVisible) {
                    controlPanel.classList.remove('translate-y-full');
                }

                // Get image data from canvas
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const pixels = imageData.data;

                // Analyze pixels and collect green pixel positions
                let greenPixels = 0;
                let totalPixels = 0;
                const greenPositions = []; // Store positions of green pixels

                // Sample every 4th pixel for performance
                const sampleRate = 4;

                for (let i = 0; i < pixels.length; i += 4 * sampleRate) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    const a = pixels[i + 3];

                    // Skip transparent pixels
                    if (a < 128) continue;

                    totalPixels++;

                    if (isGreenPixel(r, g, b)) {
                        greenPixels++;

                        // Calculate pixel position correctly accounting for sample rate
                        // i is the byte index in the pixel array (RGBA = 4 bytes per pixel)
                        // We're sampling every sampleRate pixels, so we need to account for that
                        const sampledPixelIndex = (i / 4) / sampleRate;
                        const pixelX = (sampledPixelIndex % (canvas.width / sampleRate)) * sampleRate;
                        const pixelY = Math.floor(sampledPixelIndex / (canvas.width / sampleRate)) * sampleRate;

                        greenPositions.push({ x: pixelX, y: pixelY });
                    }

                }

                // Calculate coverage percentage
                const coveragePercent = totalPixels > 0 ? (greenPixels / totalPixels) * 100 : 0;

                // Clear existing trees
                clearTrees();

                // Place trees at green pixel locations
                if (greenPositions.length > 0 && currentPolygon) {
                    const density = parseInt(treeDensitySlider.value);
                    // Calculate target tree count based on density slider (5-50 trees per hectare)
                    const area = getPolygonArea(currentPolygon);
                    const targetTreeCount = Math.max(5, Math.min(
                        greenPositions.length,
                        Math.round(area * density)
                    ));

                    console.log(`Green positions found: ${greenPositions.length}`);
                    console.log(`Target tree count: ${targetTreeCount} (density: ${density}/ha, area: ${area.toFixed(2)} ha)`);

                    // Use systematic sampling for even distribution
                    const sampledPositions = [];

                    if (targetTreeCount >= greenPositions.length) {
                        // Use all positions if we need more trees than we have positions
                        sampledPositions.push(...greenPositions);
                    } else {
                        // Evenly sample across all green positions
                        const step = greenPositions.length / targetTreeCount;
                        for (let i = 0; i < targetTreeCount; i++) {
                            const index = Math.floor(i * step);
                            if (index < greenPositions.length) {
                                sampledPositions.push(greenPositions[index]);
                            }
                        }
                    }


                    // Convert canvas pixel coordinates to map lat/lng
                    // bounds is the geographic bounds of the captured area
                    const north = bounds.getNorth();
                    const south = bounds.getSouth();
                    const east = bounds.getEast();
                    const west = bounds.getWest();

                    console.log(`Placing trees from ${sampledPositions.length} green positions`);
                    console.log(`Canvas size: ${canvas.width}x${canvas.height}`);
                    console.log(`Bounds: N=${north}, S=${south}, E=${east}, W=${west}`);

                    let treesPlaced = 0;
                    sampledPositions.forEach(pos => {
                        // Convert canvas pixel to lat/lng
                        // pos.x and pos.y are in canvas coordinates (0 to canvas.width/height)
                        const latFraction = pos.y / canvas.height;
                        const lngFraction = pos.x / canvas.width;

                        // Interpolate between bounds
                        const lat = north - (latFraction * (north - south));
                        const lng = west + (lngFraction * (east - west));
                        const latlng = L.latLng(lat, lng);

                        // Check if point is inside polygon (if polygon mode)
                        const shouldPlace = currentPolygon ? isPointInPolygon(latlng, currentPolygon) : true;

                        if (shouldPlace) {
                            const treeMarker = L.circleMarker(latlng, {
                                radius: 8,
                                fillColor: '#2d5016',
                                color: '#ffffff',
                                weight: 3,
                                opacity: 1,
                                fillOpacity: 1,
                                className: 'tree-marker'
                            }).addTo(map);

                            trees.push({
                                marker: treeMarker,
                                position: latlng
                            });
                            treesPlaced++;
                        }
                    });

                    console.log(`Successfully placed ${treesPlaced} trees`);

                    // Update visualization and statistics
                    updatePhytoncideVisualization();
                    updateStatistics(area, trees.length);

                }

                const estimatedTrees = trees.length;


                // Display results
                displayAnalysisResults(greenPixels, coveragePercent, estimatedTrees);

            } catch (error) {
                console.error('Analysis error:', error);
                const currentLang = localStorage.getItem('language') || 'ru';
                const t = translations[currentLang] || translations.ru;
                alert(`${t.alertAnalysisError || '–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞'}: ${error.message}`);
            } finally {
                // Re-enable button
                analyzeBtn.disabled = false;
                const currentLang = localStorage.getItem('language') || 'ru';
                const t = translations[currentLang] || translations.ru;
                analyzeBtn.innerHTML = `<i class="fas fa-microscope"></i> ${t.btnAnalyze || '–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ–±–ª–∞—Å—Ç—å'}`;
            }
        }



        // Show approximate results when CORS blocks pixel analysis
        function showApproximateResults() {
            const currentLang = localStorage.getItem('language') || 'ru';
            const t = translations[currentLang] || translations.ru;
            const area = currentPolygon ? getPolygonArea(currentPolygon) : 0;
            const treeDensity = parseInt(treeDensitySlider.value);

            // Approximate based on tree density and area
            const approximateCoverage = Math.min(treeDensity * 2, 85);
            const approximateTrees = area > 0 ? Math.round(area * treeDensity) : trees.length;
            const approximateGreenPixels = Math.round(approximateCoverage * 1000);

            displayAnalysisResults(approximateGreenPixels, approximateCoverage, approximateTrees);

            // Show warning
            setTimeout(() => {
                alert(t.alertCORS || '‚ö†Ô∏è –ò–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π CORS –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω—ã–π —Ä–∞—Å—á–µ—Ç.');
            }, 500);

            analyzeBtn.disabled = false;
            analyzeBtn.innerHTML = `<i class="fas fa-microscope"></i> ${t.btnAnalyze || '–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ–±–ª–∞—Å—Ç—å'}`;
        }

        // Display analysis results
        function displayAnalysisResults(greenPixels, coveragePercent, estimatedTrees) {
            const resultsDiv = document.getElementById('analysisResults');
            resultsDiv.classList.remove('hidden');

            document.getElementById('greenPixelsValue').textContent = greenPixels.toLocaleString();
            document.getElementById('coverageValue').textContent = coveragePercent.toFixed(1) + '%';
            document.getElementById('estimatedTreesValue').textContent = estimatedTrees.toLocaleString() + ' –¥–µ—Ä–µ–≤—å–µ–≤';
        }

        // Analyze button click handler
        analyzeBtn.addEventListener('click', analyzePolygonArea);


        // ===== MOBILE SWIPEABLE DRAWER LOGIC =====
        const mobileSettingsBtn = document.getElementById('mobileSettingsBtn');
        const closePanelBtn = document.getElementById('closePanelBtn');
        const drawerHandle = document.getElementById('drawerHandle');
        const controlPanel = document.getElementById('controlPanel');

        let touchStartY = 0;
        let isDragging = false;
        let currentTranslate = 0;
        let initialTranslate = 0;

        function openDrawer() {
            controlPanel.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            controlPanel.style.transform = 'translateY(0)';
            controlPanel.classList.remove('translate-y-full');
            currentTranslate = 0;
            // Prevent body scroll when open on mobile
            if (window.innerWidth < 768) {
                document.body.style.overflow = 'hidden';
            }
        }

        function closeDrawer() {
            controlPanel.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            controlPanel.style.transform = 'translateY(100%)';
            controlPanel.classList.add('translate-y-full');
            currentTranslate = window.innerHeight;
            document.body.style.overflow = '';
        }

        function toggleDrawer() {
            const isClosed = controlPanel.classList.contains('translate-y-full') ||
                (controlPanel.style.transform && controlPanel.style.transform !== 'translateY(0px)');
            if (isClosed) {
                openDrawer();
            } else {
                closeDrawer();
            }
        }

        // Click handlers
        if (mobileSettingsBtn) {
            mobileSettingsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleDrawer();
            });
        }

        // Custom close button handler
        if (closePanelBtn) {
            closePanelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeDrawer();
            });
        }

        // Click on handle to close
        if (drawerHandle) {
            drawerHandle.addEventListener('click', (e) => {
                // Only close if not dragging
                if (!isDragging) {
                    closeDrawer();
                }
            });
        }

        // Touch/drag handlers for swipeable drawer
        if (drawerHandle) {
            let startY = 0;
            let currentY = 0;
            let startTime = 0;

            drawerHandle.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                startY = e.touches[0].clientY;
                currentY = startY; // Initialize currentY to startY
                startTime = Date.now();
                isDragging = true;
                controlPanel.style.transition = 'none';

                // Get current translateY
                const style = window.getComputedStyle(controlPanel);
                const matrix = new WebKitCSSMatrix(style.transform);
                initialTranslate = matrix.m42;
            }, { passive: false });

            drawerHandle.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                e.stopPropagation();
                if (e.cancelable) e.preventDefault();

                currentY = e.touches[0].clientY;
                const diff = currentY - startY;

                // Don't allow dragging above fully open
                let newTranslate = Math.max(0, initialTranslate + diff);
                controlPanel.style.transform = `translateY(${newTranslate}px)`;
                currentTranslate = newTranslate;
            }, { passive: false });

            drawerHandle.addEventListener('touchend', (e) => {
                if (!isDragging) return;
                isDragging = false;

                const endTime = Date.now();
                const duration = endTime - startTime;
                const diff = currentY - startY;

                // Snap logic: if swiped fast or moved more than 20% of height
                const threshold = window.innerHeight * 0.2;
                const velocity = Math.abs(diff) / duration;

                if (diff > threshold || (velocity > 0.5 && diff > 0)) {
                    closeDrawer();
                } else {
                    openDrawer();
                }
            }, { passive: true });
        }



        // ===== THEME & LANGUAGE MANAGEMENT =====

        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;

        // Load saved theme (default to dark)
        const savedTheme = localStorage.getItem('theme') || 'dark';
        if (savedTheme === 'dark') {
            html.classList.add('dark');
        } else {
            html.classList.remove('dark');
        }

        themeToggle.addEventListener('click', () => {
            html.classList.toggle('dark');
            const newTheme = html.classList.contains('dark') ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
        });

        // Language Management
        const langBtn = document.getElementById('langBtn');
        const langDropdown = document.getElementById('langDropdown');
        const currentLangSpan = document.getElementById('currentLang');
        const langOptions = document.querySelectorAll('.lang-option');

        // Translations object
        const translations = {
            ru: {
                backButton: "–ù–∞ –≥–ª–∞–≤–Ω—É—é",
                panelTitle: "–§–∏—Ç–æ–Ω—Ü–∏–¥—ã –µ–ª–∏",
                panelSubtitle: "–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –∫–∞—Ä—Ç–∞ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è",
                workMode: "–†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã",
                workModePolygon: "–†–∏—Å–æ–≤–∞–Ω–∏–µ –æ–±–ª–∞—Å—Ç–∏ (–∞–≤—Ç–æ-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è)",
                workModeManual: "–†—É—á–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –¥–µ—Ä–µ–≤—å–µ–≤",
                instructionBoxTitle: "–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:",
                instructionBoxText: "–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–∞—Ä—Ç–µ, –∑–∞—Ç–µ–º –∫–ª–∏–∫–∞–π—Ç–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–ª–∏–≥–æ–Ω–∞ –ª–µ—Å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –∑–∞–≤–µ—Ä—à–∞–µ—Ç —Ä–∏—Å–æ–≤–∞–Ω–∏–µ.",
                mapLayer: "–°–ª–æ–π –∫–∞—Ä—Ç—ã",
                mapLayerOsm: "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∫–∞—Ä—Ç–∞",
                mapLayerSatellite: "–°–ø—É—Ç–Ω–∏–∫–æ–≤–∞—è (–¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ª–µ—Å–æ–≤)",
                treeSection: "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–µ—Ä–µ–≤—å–µ–≤",
                treeDensity: "–ü–ª–æ—Ç–Ω–æ—Å—Ç—å –¥–µ—Ä–µ–≤—å–µ–≤",
                densityRare: "–†–µ–¥–∫–æ (5/–≥–∞)",
                densityDense: "–ì—É—Å—Ç–æ (50/–≥–∞)",
                environmentSection: "–û–∫—Ä—É–∂–∞—é—â–∞—è —Å—Ä–µ–¥–∞",
                season: "–°–µ–∑–æ–Ω",
                seasonSpring: "–í–µ—Å–Ω–∞ (‚Üë –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å)",
                seasonSummer: "–õ–µ—Ç–æ (–º–∞–∫—Å–∏–º—É–º)",
                seasonAutumn: "–û—Å–µ–Ω—å (‚Üì –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å)",
                seasonWinter: "–ó–∏–º–∞ (–º–∏–Ω–∏–º—É–º)",
                timeOfDay: "–í—Ä–µ–º—è —Å—É—Ç–æ–∫",
                timeMorning: "–£—Ç—Ä–æ (6:00-12:00)",
                timeDay: "–î–µ–Ω—å (12:00-18:00)",
                timeEvening: "–í–µ—á–µ—Ä (18:00-22:00)",
                timeNight: "–ù–æ—á—å (22:00-6:00)",
                weather: "–ü–æ–≥–æ–¥–∞",
                weatherSunny: "–°–æ–ª–Ω–µ—á–Ω–æ (‚Üë –≤—ã–¥–µ–ª–µ–Ω–∏–µ)",
                weatherCloudy: "–û–±–ª–∞—á–Ω–æ (–Ω–æ—Ä–º–∞)",
                weatherRainy: "–î–æ–∂–¥—å (‚Üì –≤—ã–¥–µ–ª–µ–Ω–∏–µ)",
                weatherFoggy: "–¢—É–º–∞–Ω (–ø–ª–æ—Ö–æ–µ —Ä–∞—Å—Å–µ–∏–≤–∞–Ω–∏–µ)",
                windSection: "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–µ—Ç—Ä–∞",
                windSpeed: "–°–∫–æ—Ä–æ—Å—Ç—å –≤–µ—Ç—Ä–∞",
                windCalm: "–®—Ç–∏–ª—å",
                windStrong: "–°–∏–ª—å–Ω—ã–π",
                windDirection: "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ç—Ä–∞",
                windNorth: "–° (0¬∞)",
                windNorthEast: "–°–í",
                windEast: "–í (90¬∞)",
                windSouthEast: "–Æ–í",
                windSouth: "–Æ (180¬∞)",
                windSouthWest: "–Æ–ó",
                windWest: "–ó (270¬∞)",
                windNorthWest: "–°–ó",
                phytoSection: "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–æ–≤",
                baseRadius: "–ë–∞–∑–æ–≤—ã–π —Ä–∞–¥–∏—É—Å –¥–µ–π—Å—Ç–≤–∏—è",
                arrayEffect: "–≠—Ñ—Ñ–µ–∫—Ç –º–∞—Å—Å–∏–≤–∞",
                effectWeak: "–°–ª–∞–±—ã–π",
                effectStrong: "–°–∏–ª—å–Ω—ã–π",
                arrayEffectDesc: "–£—Å–∏–ª–µ–Ω–∏–µ –ø—Ä–∏ –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏–∏ –∑–æ–Ω –¥–µ—Ä–µ–≤—å–µ–≤",
                instructionManual: "–ö–ª–∏–∫–∞–π—Ç–µ –ø–æ –∫–∞—Ä—Ç–µ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –¥–µ—Ä–µ–≤—å–µ–≤. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–ø—É—Ç–Ω–∏–∫–æ–≤—ã–π —Å–ª–æ–π –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö –ª–µ—Å–Ω—ã—Ö –º–∞—Å—Å–∏–≤–æ–≤.",
                visualSection: "–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è",
                layerOpacity: "–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å —Å–ª–æ—è",
                opacityTransparent: "–ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π",
                opacityOpaque: "–ù–µ–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π",
                opacityDesc: "–í–∏–¥–∏–º–æ—Å—Ç—å –∑–µ–ª–µ–Ω–æ–≥–æ —Å–ª–æ—è —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–æ–≤",
                particles: "–ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü",
                particlesDesc: "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –¥–≤–∏–∂–µ–Ω–∏–µ –∏ –∏—Å–ø–∞—Ä–µ–Ω–∏–µ —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–æ–≤",
                actionsSection: "–î–µ–π—Å—Ç–≤–∏—è",
                btnClear: "–û—á–∏—Å—Ç–∏—Ç—å",
                btnUpdate: "–û–±–Ω–æ–≤–∏—Ç—å",
                btnAnalyze: "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ–±–ª–∞—Å—Ç—å",
                analyzeDesc: "–ê–Ω–∞–ª–∏–∑ –∑–µ–ª–µ–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π –Ω–∞ —Å–ø—É—Ç–Ω–∏–∫–æ–≤–æ–º —Å–Ω–∏–º–∫–µ",
                statsTitle: "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
                statArea: "–ü–ª–æ—â–∞–¥—å",
                statTrees: "–î–µ—Ä–µ–≤—å–µ–≤",
                statRadius: "–ú–∞–∫—Å. —Ä–∞–¥–∏—É—Å",
                statMultiplier: "–ú–Ω–æ–∂–∏—Ç–µ–ª—å",
                resultsTitle: "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞",
                resGreenPixels: "–ó–µ–ª–µ–Ω—ã–µ –ø–∏–∫—Å–µ–ª–∏",
                resCoverage: "–ü–æ–∫—Ä—ã—Ç–∏–µ",
                resEstTrees: "–û—Ü–µ–Ω–∫–∞ –¥–µ—Ä–µ–≤—å–µ–≤",
                resInfo: "–ê–Ω–∞–ª–∏–∑ –æ—Å–Ω–æ–≤–∞–Ω –Ω–∞ —Ü–≤–µ—Ç–æ–≤–æ–º —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–∏ –∑–µ–ª–µ–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π",
                legendTitle: "–õ–µ–≥–µ–Ω–¥–∞",
                legendSpruce: "–ï–ª—å (–¥–µ—Ä–µ–≤–æ)",
                legendConcentration: "–ö–æ–Ω—Ü–µ–Ω—Ç—Ä–∞—Ü–∏—è —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–æ–≤:",
                legendLow: "–ù–∏–∑–∫–∞—è",
                legendHigh: "–í—ã—Å–æ–∫–∞—è",
                attribution: "–ù–∞—É—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Å–Ω–æ–≤–∞–Ω—ã –Ω–∞ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è—Ö —Ñ–∏—Ç–æ–Ω—Ü–∏–¥–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ö–≤–æ–π–Ω—ã—Ö",
                alertDrawFirst: "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ä–∏—Å—É–π—Ç–µ –æ–±–ª–∞—Å—Ç—å –∏–ª–∏ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç–µ –¥–µ—Ä–µ–≤—å—è!",
                btnAnalyzing: "–ê–Ω–∞–ª–∏–∑...",
                alertAnalysisError: "–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞",
                alertCORS: "‚ö†Ô∏è –ò–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π CORS –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω—ã–π —Ä–∞—Å—á–µ—Ç.\n\n–î–ª—è —Ç–æ—á–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –ø–∏–∫—Å–µ–ª–µ–π —Ç—Ä–µ–±—É–µ—Ç—Å—è –ø—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω—ã—Ö —Ç–∞–π–ª–æ–≤."
            },
            kz: {
                backButton: "–ë–∞—Å—Ç—ã –±–µ—Ç–∫–µ",
                panelTitle: "–®—ã—Ä—à–∞ —Ñ–∏—Ç–æ–Ω—Ü–∏–¥—Ç–µ—Ä—ñ",
                panelSubtitle: "–¢–∞—Ä–∞–ª—É–¥—ã“£ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤—Ç—ñ –∫–∞—Ä—Ç–∞—Å—ã",
                workMode: "–ñ“±–º—ã—Å —Ä–µ–∂–∏–º—ñ",
                workModePolygon: "–ê–π–º–∞“õ—Ç—ã —Å—ã–∑—É (–∞–≤—Ç–æ-–≥–µ–Ω–µ—Ä–∞—Ü–∏—è)",
                workModeManual: "–ê“ì–∞—à—Ç–∞—Ä–¥—ã “õ–æ–ª–º–µ–Ω –æ—Ä–Ω–∞–ª–∞—Å—Ç—ã—Ä—É",
                instructionBoxTitle: "–ù“±—Å“õ–∞—É–ª—ã“õ:",
                instructionBoxText: "–ö–∞—Ä—Ç–∞–¥–∞ –±–∞—Å—ã“£—ã–∑, —Å–æ–¥–∞–Ω –∫–µ–π—ñ–Ω –æ—Ä–º–∞–Ω –∞–π–º–∞“ì—ã–Ω—ã“£ –ø–æ–ª–∏–≥–æ–Ω—ã–Ω –∂–∞—Å–∞—É “Ø—à—ñ–Ω –±–∞—Å—ã“£—ã–∑. “ö–æ—Å –±–∞—Å—É –∞—è“õ—Ç–∞–π–¥—ã.",
                mapLayer: "–ö–∞—Ä—Ç–∞ “õ–∞–±–∞—Ç—ã",
                mapLayerOsm: "–°—Ç–∞–Ω–¥–∞—Ä—Ç—Ç—ã –∫–∞—Ä—Ç–∞",
                mapLayerSatellite: "–°–ø—É—Ç–Ω–∏–∫—Ç—ñ–∫ (–æ—Ä–º–∞–Ω–¥–∞—Ä–¥—ã –∞–Ω—ã“õ—Ç–∞—É “Ø—à—ñ–Ω)",
                treeSection: "–ê“ì–∞—à –ø–∞—Ä–∞–º–µ—Ç—Ä–ª–µ—Ä—ñ",
                treeDensity: "–ê“ì–∞—à —Ç—ã“ì—ã–∑–¥—ã“ì—ã",
                densityRare: "–°–∏—Ä–µ–∫ (5/–≥–∞)",
                densityDense: "–¢—ã“ì—ã–∑ (50/–≥–∞)",
                environmentSection: "“ö–æ—Ä—à–∞“ì–∞–Ω –æ—Ä—Ç–∞",
                season: "–ú–∞—É—Å—ã–º",
                seasonSpring: "–ö”©–∫—Ç–µ–º (‚Üë –±–µ–ª—Å–µ–Ω–¥—ñ–ª—ñ–∫)",
                seasonSummer: "–ñ–∞–∑ (–º–∞–∫—Å–∏–º—É–º)",
                seasonAutumn: "–ö“Ø–∑ (‚Üì –±–µ–ª—Å–µ–Ω–¥—ñ–ª—ñ–∫)",
                seasonWinter: "“ö—ã—Å (–º–∏–Ω–∏–º—É–º)",
                timeOfDay: "–¢”ô—É–ª—ñ–∫ —É–∞“õ—ã—Ç—ã",
                timeMorning: "–¢–∞“£ (6:00-12:00)",
                timeDay: "–ö“Ø–Ω (12:00-18:00)",
                timeEvening: "–ö–µ—à (18:00-22:00)",
                timeNight: "–¢“Ø–Ω (22:00-6:00)",
                weather: "–ê—É–∞ —Ä–∞–π—ã",
                weatherSunny: "–ê—à—ã“õ (‚Üë –±”©–ª—É)",
                weatherCloudy: "–ë“±–ª—Ç—Ç—ã (–Ω–æ—Ä–º–∞)",
                weatherRainy: "–ñ–∞“£–±—ã—Ä (‚Üì –±”©–ª—É)",
                weatherFoggy: "–¢“±–º–∞–Ω (–Ω–∞—à–∞—Ä —Ç–∞—Ä–∞–ª—É)",
                windSection: "–ñ–µ–ª –ø–∞—Ä–∞–º–µ—Ç—Ä–ª–µ—Ä—ñ",
                windSpeed: "–ñ–µ–ª –∂—ã–ª–¥–∞–º–¥—ã“ì—ã",
                windCalm: "–®—Ç–∏–ª—å",
                windStrong: "–ö“Ø—à—Ç—ñ",
                windDirection: "–ñ–µ–ª –±–∞“ì—ã—Ç—ã",
                windNorth: "–° (0¬∞)",
                windNorthEast: "–°–®",
                windEast: "–® (90¬∞)",
                windSouthEast: "–û–®",
                windSouth: "–û (180¬∞)",
                windSouthWest: "–û–ë",
                windWest: "–ë (270¬∞)",
                windNorthWest: "–°–ë",
                phytoSection: "–§–∏—Ç–æ–Ω—Ü–∏–¥ –ø–∞—Ä–∞–º–µ—Ç—Ä–ª–µ—Ä—ñ",
                baseRadius: "–ë–∞–∑–∞–ª—ã“õ ”ô—Å–µ—Ä —Ä–∞–¥–∏—É—Å—ã",
                arrayEffect: "–ú–∞—Å—Å–∏–≤ —ç—Ñ—Ñ–µ–∫—Ç—ñ—Å—ñ",
                effectWeak: "”ò–ª—Å—ñ–∑",
                effectStrong: "–ö“Ø—à—Ç—ñ",
                arrayEffectDesc: "–ê“ì–∞—à –∞–π–º–∞“õ—Ç–∞—Ä—ã–Ω—ã“£ “õ–∞–±–∞—Ç—Ç–∞—Å—É—ã–Ω–¥–∞ –∫“Ø—à–µ—é",
                instructionManual: "–ê“ì–∞—à—Ç–∞—Ä–¥—ã –æ—Ä–Ω–∞–ª–∞—Å—Ç—ã—Ä—É “Ø—à—ñ–Ω –∫–∞—Ä—Ç–∞–Ω—ã –±–∞—Å—ã“£—ã–∑. –ù–∞“õ—Ç—ã –æ—Ä–º–∞–Ω –º–∞—Å—Å–∏–≤—Ç–µ—Ä—ñ–Ω –∞–Ω—ã“õ—Ç–∞—É “Ø—à—ñ–Ω —Å–ø—É—Ç–Ω–∏–∫—Ç—ñ–∫ “õ–∞–±–∞—Ç—Ç—ã –ø–∞–π–¥–∞–ª–∞–Ω—ã“£—ã–∑.",
                visualSection: "–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è",
                layerOpacity: "“ö–∞–±–∞—Ç –º”©–ª–¥—ñ—Ä–ª—ñ–≥—ñ",
                opacityTransparent: "–ú”©–ª–¥—ñ—Ä",
                opacityOpaque: "–ú”©–ª–¥—ñ—Ä –µ–º–µ—Å",
                opacityDesc: "–ñ–∞—Å—ã–ª —Ñ–∏—Ç–æ–Ω—Ü–∏–¥ “õ–∞–±–∞—Ç—ã–Ω—ã“£ –∫”©—Ä—ñ–Ω—É—ñ",
                particles: "–ë”©–ª—à–µ–∫—Ç–µ—Ä –∞–Ω–∏–º–∞—Ü–∏—è—Å—ã",
                particlesDesc: "–§–∏—Ç–æ–Ω—Ü–∏–¥—Ç–µ—Ä–¥—ñ“£ “õ–æ–∑“ì–∞–ª—ã—Å—ã –º–µ–Ω –±—É–ª–∞–Ω—É—ã–Ω –∫”©—Ä—Å–µ—Ç—É",
                actionsSection: "”ò—Ä–µ–∫–µ—Ç—Ç–µ—Ä",
                btnClear: "–¢–∞–∑–∞–ª–∞—É",
                btnUpdate: "–ñ–∞“£–∞—Ä—Ç—É",
                btnAnalyze: "–ê–π–º–∞“õ—Ç—ã —Ç–∞–ª–¥–∞—É",
                analyzeDesc: "–°–ø—É—Ç–Ω–∏–∫—Ç—ñ–∫ —Å—É—Ä–µ—Ç—Ç–µ–≥—ñ –∂–∞—Å—ã–ª –ø–∏–∫—Å–µ–ª—å–¥–µ—Ä–¥—ñ —Ç–∞–ª–¥–∞—É",
                statsTitle: "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
                statArea: "–ê—É–º–∞“õ",
                statTrees: "–ê“ì–∞—à—Ç–∞—Ä",
                statRadius: "–ú–∞–∫—Å. —Ä–∞–¥–∏—É—Å",
                statMultiplier: "–ö”©–±–µ–π—Ç–∫—ñ—à",
                resultsTitle: "–¢–∞–ª–¥–∞—É –Ω”ô—Ç–∏–∂–µ–ª–µ—Ä—ñ",
                resGreenPixels: "–ñ–∞—Å—ã–ª –ø–∏–∫—Å–µ–ª—å–¥–µ—Ä",
                resCoverage: "”®—Å—ñ–º–¥—ñ–∫ –∂–∞–±—ã–Ω—ã",
                resEstTrees: "–ê“ì–∞—à—Ç–∞—Ä–¥—ã –±–∞“ì–∞–ª–∞—É",
                resInfo: "–¢–∞–ª–¥–∞—É –∂–∞—Å—ã–ª –ø–∏–∫—Å–µ–ª—å–¥–µ—Ä–¥—ñ —Ç“Ø—Å—Ç—ñ–∫ —Ç–∞–Ω—É“ì–∞ –Ω–µ–≥—ñ–∑–¥–µ–ª–≥–µ–Ω",
                legendTitle: "–õ–µ–≥–µ–Ω–¥–∞",
                legendSpruce: "–®—ã—Ä—à–∞ (–∞“ì–∞—à)",
                legendConcentration: "–§–∏—Ç–æ–Ω—Ü–∏–¥ –∫–æ–Ω—Ü–µ–Ω—Ç—Ä–∞—Ü–∏—è—Å—ã:",
                legendLow: "–¢”©–º–µ–Ω",
                legendHigh: "–ñ–æ“ì–∞—Ä—ã",
                attribution: "“í—ã–ª—ã–º–∏ –¥–µ—Ä–µ–∫—Ç–µ—Ä “õ—ã–ª“õ–∞–Ω –∂–∞–ø—ã—Ä–∞“õ—Ç—ã –∞“ì–∞—à—Ç–∞—Ä–¥—ã“£ —Ñ–∏—Ç–æ–Ω—Ü–∏–¥—Ç—ñ–∫ –±–µ–ª—Å–µ–Ω–¥—ñ–ª—ñ–≥—ñ–Ω –∑–µ—Ä—Ç—Ç–µ—É–≥–µ –Ω–µ–≥—ñ–∑–¥–µ–ª–≥–µ–Ω",
                alertDrawFirst: "–ê–ª–¥—ã–º–µ–Ω –∞–π–º–∞“õ—Ç—ã —Å—ã–∑—ã“£—ã–∑ –Ω–µ–º–µ—Å–µ –∞“ì–∞—à—Ç–∞—Ä–¥—ã –æ—Ä–Ω–∞–ª–∞—Å—Ç—ã—Ä—ã“£—ã–∑!",
                btnAnalyzing: "–¢–∞–ª–¥–∞—É...",
                alertAnalysisError: "–¢–∞–ª–¥–∞—É “õ–∞—Ç–µ—Å—ñ",
                alertCORS: "‚ö†Ô∏è CORS —à–µ–∫—Ç–µ—É–ª–µ—Ä—ñ–Ω–µ –±–∞–π–ª–∞–Ω—ã—Å—Ç—ã —à–∞–º–∞–º–µ–Ω –µ—Å–µ–ø—Ç–µ—É –ø–∞–π–¥–∞–ª–∞–Ω—ã–ª–¥—ã.\n\n–ü–∏–∫—Å–µ–ª—å–¥–µ—Ä–¥—ñ –¥”ô–ª —Ç–∞–ª–¥–∞—É “Ø—à—ñ–Ω –ø—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä –Ω–µ–º–µ—Å–µ –∂–µ—Ä–≥—ñ–ª—ñ–∫—Ç—ñ —Ç–∞–π–ª–¥–∞—Ä–¥—ã –ø–∞–π–¥–∞–ª–∞–Ω—É “õ–∞–∂–µ—Ç."
            },
            en: {
                backButton: "Back to Home",
                panelTitle: "Spruce Phytoncides",
                panelSubtitle: "Interactive distribution map",
                workMode: "Work Mode",
                workModePolygon: "Area Drawing (auto-generation)",
                workModeManual: "Manual Tree Placement",
                instructionBoxTitle: "Instructions:",
                instructionBoxText: "Click on the map, then click to create a forest area polygon. Double-click to finish.",
                mapLayer: "Map Layer",
                mapLayerOsm: "Standard Map",
                mapLayerSatellite: "Satellite (for forest identification)",
                treeSection: "Tree Parameters",
                treeDensity: "Tree Density",
                densityRare: "Rare (5/ha)",
                densityDense: "Dense (50/ha)",
                environmentSection: "Environment",
                season: "Season",
                seasonSpring: "Spring (‚Üë activity)",
                seasonSummer: "Summer (maximum)",
                seasonAutumn: "Autumn (‚Üì activity)",
                seasonWinter: "Winter (minimum)",
                timeOfDay: "Time of Day",
                timeMorning: "Morning (6:00-12:00)",
                timeDay: "Day (12:00-18:00)",
                timeEvening: "Evening (18:00-22:00)",
                timeNight: "Night (22:00-6:00)",
                weather: "Weather",
                weatherSunny: "Sunny (‚Üë emission)",
                weatherCloudy: "Cloudy (normal)",
                weatherRainy: "Rain (‚Üì emission)",
                weatherFoggy: "Fog (poor dispersion)",
                windSection: "Wind Parameters",
                windSpeed: "Wind Speed",
                windCalm: "Calm",
                windStrong: "Strong",
                windDirection: "Wind Direction",
                windNorth: "N (0¬∞)",
                windNorthEast: "NE",
                windEast: "E (90¬∞)",
                windSouthEast: "SE",
                windSouth: "S (180¬∞)",
                windSouthWest: "SW",
                windWest: "W (270¬∞)",
                windNorthWest: "NW",
                phytoSection: "Phytoncide Parameters",
                baseRadius: "Base Action Radius",
                arrayEffect: "Array Effect",
                effectWeak: "Weak",
                effectStrong: "Strong",
                arrayEffectDesc: "Enhancement when tree zones overlap",
                instructionManual: "Click on the map to place trees. Use satellite layer to identify real forest areas.",
                visualSection: "Visualization",
                layerOpacity: "Layer Opacity",
                opacityTransparent: "Transparent",
                opacityOpaque: "Opaque",
                opacityDesc: "Visibility of green phytoncide layer",
                particles: "Particle Animation",
                particlesDesc: "Show movement and evaporation of phytoncides",
                actionsSection: "Actions",
                btnClear: "Clear",
                btnUpdate: "Update",
                btnAnalyze: "Analyze Area",
                analyzeDesc: "Analysis of green pixels on satellite image",
                statsTitle: "Statistics",
                statArea: "Area",
                statTrees: "Trees",
                statRadius: "Max. Radius",
                statMultiplier: "Multiplier",
                resultsTitle: "Analysis Results",
                resGreenPixels: "Green Pixels",
                resCoverage: "Coverage",
                resEstTrees: "Estimated Trees",
                resInfo: "Analysis is based on color recognition of green pixels",
                legendTitle: "Legend",
                legendSpruce: "Spruce (tree)",
                legendConcentration: "Phytoncide Concentration:",
                legendLow: "Low",
                legendHigh: "High",
                attribution: "Scientific data is based on studies of phytoncide activity in conifers",
                alertDrawFirst: "Draw an area or place trees first!",
                btnAnalyzing: "Analyzing...",
                alertAnalysisError: "Analysis Error",
                alertCORS: "‚ö†Ô∏è Due to CORS restrictions, an approximate calculation was used.\n\nAccurate pixel analysis requires a proxy server or local tiles."
            },
            es: {
                backButton: "Volver al inicio",
                panelTitle: "Fitoncidas de Abeto",
                panelSubtitle: "Mapa interactivo de distribuci√≥n",
                workMode: "Modo de trabajo",
                workModePolygon: "Dibujo de √°rea (auto-generaci√≥n)",
                workModeManual: "Colocaci√≥n manual de √°rboles",
                instructionBoxTitle: "Instrucciones:",
                instructionBoxText: "Haga clic en el mapa, luego haga clic para crear un pol√≠gono de √°rea forestal. Doble clic para finalizar.",
                mapLayer: "Capa del mapa",
                mapLayerOsm: "Mapa est√°ndar",
                mapLayerSatellite: "Sat√©lite (para identificaci√≥n de bosques)",
                treeSection: "Par√°metros de √°rboles",
                treeDensity: "Densidad de √°rboles",
                densityRare: "Raro (5/ha)",
                densityDense: "Denso (50/ha)",
                environmentSection: "Ambiente",
                season: "Estaci√≥n",
                seasonSpring: "Primavera (‚Üë actividad)",
                seasonSummer: "Verano (m√°ximo)",
                seasonAutumn: "Oto√±o (‚Üì actividad)",
                seasonWinter: "Invierno (m√≠nimo)",
                timeOfDay: "Hora del d√≠a",
                timeMorning: "Ma√±ana (6:00-12:00)",
                timeDay: "D√≠a (12:00-18:00)",
                timeEvening: "Tarde (18:00-22:00)",
                timeNight: "Noche (22:00-6:00)",
                weather: "Clima",
                weatherSunny: "Soleado (‚Üë emisi√≥n)",
                weatherCloudy: "Nublado (normal)",
                weatherRainy: "Lluvia (‚Üì emisi√≥n)",
                weatherFoggy: "Niebla (mala dispersi√≥n)",
                windSection: "Par√°metros del viento",
                windSpeed: "Velocidad del viento",
                windCalm: "Calma",
                windStrong: "Fuerte",
                windDirection: "Direcci√≥n del viento",
                windNorth: "N (0¬∞)",
                windNorthEast: "NE",
                windEast: "E (90¬∞)",
                windSouthEast: "SE",
                windSouth: "S (180¬∞)",
                windSouthWest: "SO",
                windWest: "O (270¬∞)",
                windNorthWest: "NO",
                phytoSection: "Par√°metros de fitoncidas",
                baseRadius: "Radio de acci√≥n base",
                arrayEffect: "Efecto de matriz",
                effectWeak: "D√©bil",
                effectStrong: "Fuerte",
                arrayEffectDesc: "Mejora cuando las zonas de √°rboles se superponen",
                instructionManual: "Haga clic en el mapa para colocar √°rboles. Use la capa satelital para identificar √°reas forestales reales.",
                visualSection: "Visualizaci√≥n",
                layerOpacity: "Opacidad de capa",
                opacityTransparent: "Transparente",
                opacityOpaque: "Opaco",
                opacityDesc: "Visibilidad de la capa verde de fitoncidas",
                particles: "Animaci√≥n de part√≠culas",
                particlesDesc: "Mostrar movimiento y evaporaci√≥n de fitoncidas",
                actionsSection: "Acciones",
                btnClear: "Limpiar",
                btnUpdate: "Actualizar",
                btnAnalyze: "Analizar √°rea",
                analyzeDesc: "An√°lisis de p√≠xeles verdes en imagen satelital",
                statsTitle: "Estad√≠sticas",
                statArea: "√Årea",
                statTrees: "√Årboles",
                statRadius: "Radio m√°x.",
                statMultiplier: "Multiplicador",
                resultsTitle: "Resultados del an√°lisis",
                resGreenPixels: "P√≠xeles verdes",
                resCoverage: "Cobertura",
                resEstTrees: "√Årboles estimados",
                resInfo: "El an√°lisis se basa en el reconocimiento de color de los p√≠xeles verdes",
                legendTitle: "Leyenda",
                legendSpruce: "Abeto (√°rbol)",
                legendConcentration: "Concentraci√≥n de fitoncidas:",
                legendLow: "Baja",
                legendHigh: "Alta",
                attribution: "Los datos cient√≠ficos se basan en estudios de la actividad fitoncida en con√≠feras",
                alertDrawFirst: "¬°Primero dibuje un √°rea o coloque √°rboles!",
                btnAnalyzing: "Analizando...",
                alertAnalysisError: "Error de an√°lisis",
                alertCORS: "‚ö†Ô∏è Debido a las restricciones de CORS, se utiliz√≥ un c√°lculo aproximado.\n\nEl an√°lisis preciso de p√≠xeles requiere un servidor proxy o mosaicos locales."
            },
            zh: {
                backButton: "ËøîÂõûÈ¶ñÈ°µ",
                panelTitle: "‰∫ëÊùâÊ§çÁâ©ÊùÄËèåÁ¥†",
                panelSubtitle: "‰∫§‰∫íÂºèÂàÜÂ∏ÉÂú∞Âõæ",
                workMode: "Â∑•‰ΩúÊ®°Âºè",
                workModePolygon: "Âå∫ÂüüÁªòÂà∂ÔºàËá™Âä®ÁîüÊàêÔºâ",
                workModeManual: "ÊâãÂä®ÊîæÁΩÆÊ†ëÊú®",
                instructionBoxTitle: "ËØ¥ÊòéÔºö",
                instructionBoxText: "ÁÇπÂáªÂú∞ÂõæÔºåÁÑ∂ÂêéÁÇπÂáªÂàõÂª∫Ê£ÆÊûóÂå∫ÂüüÂ§öËæπÂΩ¢„ÄÇÂèåÂáªÂÆåÊàê„ÄÇ",
                mapLayer: "Âú∞ÂõæÂõæÂ±Ç",
                mapLayerOsm: "Ê†áÂáÜÂú∞Âõæ",
                mapLayerSatellite: "Âç´ÊòüÔºàÁî®‰∫éÊ£ÆÊûóËØÜÂà´Ôºâ",
                treeSection: "Ê†ëÊú®ÂèÇÊï∞",
                treeDensity: "Ê†ëÊú®ÂØÜÂ∫¶",
                densityRare: "Á®ÄÁñè (5/ÂÖ¨È°∑)",
                densityDense: "ËåÇÂØÜ (50/ÂÖ¨È°∑)",
                environmentSection: "ÁéØÂ¢É",
                season: "Â≠£ËäÇ",
                seasonSpring: "Êò•Â≠£Ôºà‚ÜëÊ¥ªÂä®Ôºâ",
                seasonSummer: "Â§èÂ≠£ÔºàÊúÄÂ§ßÔºâ",
                seasonAutumn: "ÁßãÂ≠£Ôºà‚ÜìÊ¥ªÂä®Ôºâ",
                seasonWinter: "ÂÜ¨Â≠£ÔºàÊúÄÂ∞èÔºâ",
                timeOfDay: "‰∏ÄÂ§©‰∏≠ÁöÑÊó∂Èó¥",
                timeMorning: "Êó©Êô®Ôºà6:00-12:00Ôºâ",
                timeDay: "ÁôΩÂ§©Ôºà12:00-18:00Ôºâ",
                timeEvening: "ÂÇçÊôöÔºà18:00-22:00Ôºâ",
                timeNight: "Â§úÊôöÔºà22:00-6:00Ôºâ",
                weather: "Â§©Ê∞î",
                weatherSunny: "Êô¥Â§©Ôºà‚ÜëÊéíÊîæÔºâ",
                weatherCloudy: "Â§ö‰∫ëÔºàÊ≠£Â∏∏Ôºâ",
                weatherRainy: "Èõ®Â§©Ôºà‚ÜìÊéíÊîæÔºâ",
                weatherFoggy: "ÈõæÔºàÊâ©Êï£Â∑ÆÔºâ",
                windSection: "È£éÂèÇÊï∞",
                windSpeed: "È£éÈÄü",
                windCalm: "Âπ≥Èùô",
                windStrong: "Âº∫È£é",
                windDirection: "È£éÂêë",
                windNorth: "Âåó (0¬∞)",
                windNorthEast: "‰∏úÂåó",
                windEast: "‰∏ú (90¬∞)",
                windSouthEast: "‰∏úÂçó",
                windSouth: "Âçó (180¬∞)",
                windSouthWest: "Ë•øÂçó",
                windWest: "Ë•ø (270¬∞)",
                windNorthWest: "Ë•øÂåó",
                phytoSection: "Ê§çÁâ©ÊùÄËèåÁ¥†ÂèÇÊï∞",
                baseRadius: "Âü∫Á°Ä‰ΩúÁî®ÂçäÂæÑ",
                arrayEffect: "ÈòµÂàóÊïàÂ∫î",
                effectWeak: "Âº±",
                effectStrong: "Âº∫",
                arrayEffectDesc: "Ê†ëÊú®Âå∫ÂüüÈáçÂè†Êó∂ÁöÑÂ¢ûÂº∫",
                instructionManual: "ÁÇπÂáªÂú∞ÂõæÊîæÁΩÆÊ†ëÊú®„ÄÇ‰ΩøÁî®Âç´ÊòüÂõæÂ±ÇËØÜÂà´ÁúüÂÆûÊ£ÆÊûóÂå∫Âüü„ÄÇ",
                visualSection: "ÂèØËßÜÂåñ",
                layerOpacity: "ÂõæÂ±Ç‰∏çÈÄèÊòéÂ∫¶",
                opacityTransparent: "ÈÄèÊòé",
                opacityOpaque: "‰∏çÈÄèÊòé",
                opacityDesc: "ÁªøËâ≤Ê§çÁâ©ÊùÄËèåÁ¥†Â±ÇÁöÑÂèØËßÅÊÄß",
                particles: "Á≤íÂ≠êÂä®Áîª",
                particlesDesc: "ÊòæÁ§∫Ê§çÁâ©ÊùÄËèåÁ¥†ÁöÑËøêÂä®ÂíåËí∏Âèë",
                actionsSection: "Êìç‰Ωú",
                btnClear: "Ê∏ÖÈô§",
                btnUpdate: "Êõ¥Êñ∞",
                btnAnalyze: "ÂàÜÊûêÂå∫Âüü",
                analyzeDesc: "Âü∫‰∫éÂç´ÊòüÂõæÂÉèÁöÑÁªøËâ≤ÂÉèÁ¥†ÂàÜÊûê",
                statsTitle: "ÁªüËÆ°",
                statArea: "Èù¢ÁßØ",
                statTrees: "Ê†ëÊú®",
                statRadius: "ÊúÄÂ§ßÂçäÂæÑ",
                statMultiplier: "Á≥ªÊï∞",
                resultsTitle: "ÂàÜÊûêÁªìÊûú",
                resGreenPixels: "ÁªøËâ≤ÂÉèÁ¥†",
                resCoverage: "Ë¶ÜÁõñÁéá",
                resEstTrees: "‰º∞ËÆ°Ê†ëÊú®",
                resInfo: "ÂàÜÊûêÂü∫‰∫éÁªøËâ≤ÂÉèÁ¥†ÁöÑÈ¢úËâ≤ËØÜÂà´",
                legendTitle: "Âõæ‰æã",
                legendSpruce: "‰∫ëÊùâ (Ê†ëÊú®)",
                legendConcentration: "Ê§çÁâ©ÊùÄËèåÁ¥†ÊµìÂ∫¶Ôºö",
                legendLow: "‰Ωé",
                legendHigh: "È´ò",
                attribution: "ÁßëÂ≠¶Êï∞ÊçÆÂü∫‰∫éÈíàÂØπÈíàÂè∂Ê†ëÊ§çÁâ©ÊùÄËèåÊ¥ªÊÄßÁöÑÁ†îÁ©∂",
                alertDrawFirst: "ËØ∑ÂÖàÁªòÂà∂Âå∫ÂüüÊàñÊîæÁΩÆÊ†ëÊú®ÔºÅ",
                btnAnalyzing: "ÂàÜÊûê‰∏≠...",
                alertAnalysisError: "ÂàÜÊûêÈîôËØØ",
                alertCORS: "‚ö†Ô∏è Áî±‰∫é CORS ÈôêÂà∂Ôºå‰ΩøÁî®‰∫ÜËøë‰ººËÆ°ÁÆó„ÄÇ\n\nÂáÜÁ°ÆÁöÑÂÉèÁ¥†ÂàÜÊûêÈúÄË¶Å‰ª£ÁêÜÊúçÂä°Âô®ÊàñÊú¨Âú∞Áì¶Áâá„ÄÇ"
            }
        };

        // Load saved language
        const savedLang = localStorage.getItem('language') || 'ru';
        setLanguage(savedLang);

        // Toggle dropdown
        langBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            langDropdown.classList.toggle('active');
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            langDropdown.classList.remove('active');
        });

        // Language selection
        langOptions.forEach(option => {
            option.addEventListener('click', (e) => {
                e.stopPropagation();
                const lang = option.dataset.lang;
                setLanguage(lang);
                localStorage.setItem('language', lang);
                langDropdown.classList.remove('active');
            });
        });

        // Set language function
        function setLanguage(lang) {
            const langMap = {
                ru: 'RU',
                kz: 'KZ',
                en: 'EN',
                es: 'ES',
                zh: 'ZH'
            };

            currentLangSpan.textContent = langMap[lang] || 'RU';

            const t = translations[lang] || translations.ru;

            // Update all elements with data-i18n
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (t[key]) {
                    // Specific handling for different element types if needed
                    if (element.tagName === 'INPUT' && (element.type === 'button' || element.type === 'submit')) {
                        element.value = t[key];
                    } else if (element.tagName === 'OPTION') {
                        element.text = t[key];
                    } else {
                        element.textContent = t[key];
                    }
                }
            });

            // Update Analyze button text specifically to preserve icon
            if (analyzeBtn && t.btnAnalyze) {
                analyzeBtn.innerHTML = `<i class="fas fa-microscope"></i> ${t.btnAnalyze}`;
            }

            // Update instruction text
            updateInstructionText();

            // Refresh wind direction label if visible
            const degrees = parseInt(windDirectionSlider.value);
            const directions = {
                0: t.windNorth || '–°', 45: t.windNorthEast || '–°–í', 90: t.windEast || '–í', 135: t.windSouthEast || '–Æ–í',
                180: t.windSouth || '–Æ', 225: t.windSouthWest || '–Æ–ó', 270: t.windWest || '–ó', 315: t.windNorthWest || '–°–ó'
            };
            const nearest = Math.round(degrees / 45) * 45;
            const dirLabel = directions[nearest % 360] || (t.windNorth || '–°');
            windDirectionValue.textContent = `${dirLabel} (${degrees}¬∞)`;
        }


    </script>

</body>

</html>